{
  "resolvedId": "D:/Project/Project/project-front/vue-user-template-new/node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as errors from '../../../base/common/errors.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { IModelService } from './model.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { SemanticTokensProviderStyling, toMultilineTokens2 } from './semanticTokensProviderStyling.js';\nimport { getDocumentSemanticTokens, hasDocumentSemanticTokensProvider, isSemanticTokens, isSemanticTokensEdits } from './getSemanticTokens.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { ILanguageFeatureDebounceService } from './languageFeatureDebounce.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nfunction computeModelSha1(model) {\n    // compute the sha1\n    const shaComputer = new StringSHA1();\n    const snapshot = model.createSnapshot();\n    let text;\n    while ((text = snapshot.read())) {\n        shaComputer.update(text);\n    }\n    return shaComputer.digest();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._languageSelection = null;\n        this._languageSelectionListener = null;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    _disposeLanguageSelection() {\n        if (this._languageSelectionListener) {\n            this._languageSelectionListener.dispose();\n            this._languageSelectionListener = null;\n        }\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n        this._disposeLanguageSelection();\n    }\n    setLanguage(languageSelection) {\n        this._disposeLanguageSelection();\n        this._languageSelection = languageSelection;\n        this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(languageSelection.languageId));\n        this.model.setMode(languageSelection.languageId);\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* LF */ : 2 /* CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    constructor(_configurationService, _resourcePropertiesService, _themeService, _logService, _undoRedoService, _languageService, _languageConfigurationService, _languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._languageFeatureDebounceService = _languageFeatureDebounceService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._semanticStyling = this._register(new SemanticStyling(this._themeService, this._languageService, this._logService));\n        this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions()));\n        this._updateModelOptions();\n        this._register(new SemanticColoringFeature(this._semanticStyling, this, this._themeService, this._configurationService, this._languageFeatureDebounceService, languageFeaturesService));\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        var _a;\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = tabSize;\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = parsedIndentSize;\n            }\n            if (indentSize < 1) {\n                indentSize = 1;\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (((_a = config.editor) === null || _a === void 0 ? void 0 : _a.bracketPairColorization) && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* Linux */ || platform.OS === 2 /* Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(language, resource, isForSimpleWidget) {\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions() {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* LF */ ? 0 /* LF */ : 1 /* CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageId, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageId, resource, isForSimpleWidget);\n        const model = new TextModel(value, languageId, options, resource, this._undoRedoService, this._languageService, this._languageConfigurationService);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1IsEqual = (computeModelSha1(model) === disposedModelData.sha1);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection.languageId, resource, isForSimpleWidget);\n            this.setMode(modelData.model, languageSelection);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    setMode(model, languageSelection) {\n        if (!languageSelection) {\n            return;\n        }\n        const modelData = this._models[MODEL_ID(model.uri)];\n        if (!modelData) {\n            return;\n        }\n        modelData.setLanguage(languageSelection);\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    getSemanticTokensProviderStyling(provider) {\n        return this._semanticStyling.get(provider);\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.userData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && heapSize > maxMemory) {\n            // the undo stack for this file would never fit in the configured memory, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, computeModelSha1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n};\nModelService.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;\nModelService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IThemeService),\n    __param(3, ILogService),\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, ILanguageFeatureDebounceService),\n    __param(8, ILanguageFeaturesService)\n], ModelService);\nexport { ModelService };\nexport const SEMANTIC_HIGHLIGHTING_SETTING_ID = 'editor.semanticHighlighting';\nexport function isSemanticColoringEnabled(model, themeService, configurationService) {\n    var _a;\n    const setting = (_a = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageId(), resource: model.uri })) === null || _a === void 0 ? void 0 : _a.enabled;\n    if (typeof setting === 'boolean') {\n        return setting;\n    }\n    return themeService.getColorTheme().semanticHighlighting;\n}\nlet SemanticColoringFeature = class SemanticColoringFeature extends Disposable {\n    constructor(semanticStyling, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._watchers = Object.create(null);\n        this._semanticStyling = semanticStyling;\n        const register = (model) => {\n            this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, this._semanticStyling, themeService, languageFeatureDebounceService, languageFeaturesService);\n        };\n        const deregister = (model, modelSemanticColoring) => {\n            modelSemanticColoring.dispose();\n            delete this._watchers[model.uri.toString()];\n        };\n        const handleSettingOrThemeChange = () => {\n            for (let model of modelService.getModels()) {\n                const curr = this._watchers[model.uri.toString()];\n                if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                    if (!curr) {\n                        register(model);\n                    }\n                }\n                else {\n                    if (curr) {\n                        deregister(model, curr);\n                    }\n                }\n            }\n        };\n        this._register(modelService.onModelAdded((model) => {\n            if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                register(model);\n            }\n        }));\n        this._register(modelService.onModelRemoved((model) => {\n            const curr = this._watchers[model.uri.toString()];\n            if (curr) {\n                deregister(model, curr);\n            }\n        }));\n        this._register(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {\n                handleSettingOrThemeChange();\n            }\n        }));\n        this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));\n    }\n};\nSemanticColoringFeature = __decorate([\n    __param(1, IModelService),\n    __param(2, IThemeService),\n    __param(3, IConfigurationService),\n    __param(4, ILanguageFeatureDebounceService),\n    __param(5, ILanguageFeaturesService)\n], SemanticColoringFeature);\nclass SemanticStyling extends Disposable {\n    constructor(_themeService, _languageService, _logService) {\n        super();\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._caches = new WeakMap();\n        this._register(this._themeService.onDidColorThemeChange(() => {\n            this._caches = new WeakMap();\n        }));\n    }\n    get(provider) {\n        if (!this._caches.has(provider)) {\n            this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._languageService, this._logService));\n        }\n        return this._caches.get(provider);\n    }\n}\nclass SemanticTokensResponse {\n    constructor(provider, resultId, data) {\n        this.provider = provider;\n        this.resultId = resultId;\n        this.data = data;\n    }\n    dispose() {\n        this.provider.releaseDocumentSemanticTokens(this.resultId);\n    }\n}\nlet ModelSemanticColoring = class ModelSemanticColoring extends Disposable {\n    constructor(model, stylingProvider, themeService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._isDisposed = false;\n        this._model = model;\n        this._semanticStyling = stylingProvider;\n        this._provider = languageFeaturesService.documentSemanticTokensProvider;\n        this._debounceInformation = languageFeatureDebounceService.for(this._provider, 'DocumentSemanticTokens', { min: ModelSemanticColoring.REQUEST_MIN_DELAY, max: ModelSemanticColoring.REQUEST_MAX_DELAY });\n        this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring.REQUEST_MIN_DELAY));\n        this._currentDocumentResponse = null;\n        this._currentDocumentRequestCancellationTokenSource = null;\n        this._documentProvidersChangeListeners = [];\n        this._register(this._model.onDidChangeContent(() => {\n            if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        }));\n        this._register(this._model.onDidChangeLanguage(() => {\n            // clear any outstanding state\n            if (this._currentDocumentResponse) {\n                this._currentDocumentResponse.dispose();\n                this._currentDocumentResponse = null;\n            }\n            if (this._currentDocumentRequestCancellationTokenSource) {\n                this._currentDocumentRequestCancellationTokenSource.cancel();\n                this._currentDocumentRequestCancellationTokenSource = null;\n            }\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(0);\n        }));\n        const bindDocumentChangeListeners = () => {\n            dispose(this._documentProvidersChangeListeners);\n            this._documentProvidersChangeListeners = [];\n            for (const provider of this._provider.all(model)) {\n                if (typeof provider.onDidChange === 'function') {\n                    this._documentProvidersChangeListeners.push(provider.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));\n                }\n            }\n        };\n        bindDocumentChangeListeners();\n        this._register(this._provider.onDidChange(() => {\n            bindDocumentChangeListeners();\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }));\n        this._register(themeService.onDidColorThemeChange(_ => {\n            // clear out existing tokens\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }));\n        this._fetchDocumentSemanticTokens.schedule(0);\n    }\n    dispose() {\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            this._currentDocumentRequestCancellationTokenSource.cancel();\n            this._currentDocumentRequestCancellationTokenSource = null;\n        }\n        this._setDocumentSemanticTokens(null, null, null, []);\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _fetchDocumentSemanticTokensNow() {\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            // there is already a request running, let it finish...\n            return;\n        }\n        if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {\n            // there is no provider\n            if (this._currentDocumentResponse) {\n                // there are semantic tokens set\n                this._model.setSemanticTokens(null, false);\n            }\n            return;\n        }\n        const cancellationTokenSource = new CancellationTokenSource();\n        const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;\n        const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;\n        const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);\n        this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;\n        const pendingChanges = [];\n        const contentChangeListener = this._model.onDidChangeContent((e) => {\n            pendingChanges.push(e);\n        });\n        const sw = new StopWatch(false);\n        request.then((res) => {\n            this._debounceInformation.update(this._model, sw.elapsed());\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (!res) {\n                this._setDocumentSemanticTokens(null, null, null, pendingChanges);\n            }\n            else {\n                const { provider, tokens } = res;\n                const styling = this._semanticStyling.get(provider);\n                this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);\n            }\n        }, (err) => {\n            const isExpectedError = err && (errors.isCancellationError(err) || (typeof err.message === 'string' && err.message.indexOf('busy') !== -1));\n            if (!isExpectedError) {\n                errors.onUnexpectedError(err);\n            }\n            // Semantic tokens eats up all errors and considers errors to mean that the result is temporarily not available\n            // The API does not have a special error kind to express this...\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                    this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n                }\n            }\n        });\n    }\n    static _copy(src, srcOffset, dest, destOffset, length) {\n        for (let i = 0; i < length; i++) {\n            dest[destOffset + i] = src[srcOffset + i];\n        }\n    }\n    _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {\n        const currentResponse = this._currentDocumentResponse;\n        const rescheduleIfNeeded = () => {\n            if (pendingChanges.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        };\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._isDisposed) {\n            // disposed!\n            if (provider && tokens) {\n                provider.releaseDocumentSemanticTokens(tokens.resultId);\n            }\n            return;\n        }\n        if (!provider || !styling) {\n            this._model.setSemanticTokens(null, false);\n            return;\n        }\n        if (!tokens) {\n            this._model.setSemanticTokens(null, true);\n            rescheduleIfNeeded();\n            return;\n        }\n        if (isSemanticTokensEdits(tokens)) {\n            if (!currentResponse) {\n                // not possible!\n                this._model.setSemanticTokens(null, true);\n                return;\n            }\n            if (tokens.edits.length === 0) {\n                // nothing to do!\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: currentResponse.data\n                };\n            }\n            else {\n                let deltaLength = 0;\n                for (const edit of tokens.edits) {\n                    deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;\n                }\n                const srcData = currentResponse.data;\n                const destData = new Uint32Array(srcData.length + deltaLength);\n                let srcLastStart = srcData.length;\n                let destLastStart = destData.length;\n                for (let i = tokens.edits.length - 1; i >= 0; i--) {\n                    const edit = tokens.edits[i];\n                    const copyCount = srcLastStart - (edit.start + edit.deleteCount);\n                    if (copyCount > 0) {\n                        ModelSemanticColoring._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);\n                        destLastStart -= copyCount;\n                    }\n                    if (edit.data) {\n                        ModelSemanticColoring._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);\n                        destLastStart -= edit.data.length;\n                    }\n                    srcLastStart = edit.start;\n                }\n                if (srcLastStart > 0) {\n                    ModelSemanticColoring._copy(srcData, 0, destData, 0, srcLastStart);\n                }\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: destData\n                };\n            }\n        }\n        if (isSemanticTokens(tokens)) {\n            this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);\n            const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());\n            // Adjust incoming semantic tokens\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                // We need to:\n                // 1. Adjust incoming semantic tokens\n                // 2. Request them again\n                for (const change of pendingChanges) {\n                    for (const area of result) {\n                        for (const singleChange of change.changes) {\n                            area.applyEdit(singleChange.range, singleChange.text);\n                        }\n                    }\n                }\n            }\n            this._model.setSemanticTokens(result, true);\n        }\n        else {\n            this._model.setSemanticTokens(null, true);\n        }\n        rescheduleIfNeeded();\n    }\n};\nModelSemanticColoring.REQUEST_MIN_DELAY = 300;\nModelSemanticColoring.REQUEST_MAX_DELAY = 2000;\nModelSemanticColoring = __decorate([\n    __param(2, IThemeService),\n    __param(3, ILanguageFeatureDebounceService),\n    __param(4, ILanguageFeaturesService)\n], ModelSemanticColoring);\nexport { ModelSemanticColoring };\n",
      "start": 1711096856009,
      "end": 1711096856105,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1711096856105,
      "end": 1711096856105,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1711096856105,
      "end": 1711096856106,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1711096856106,
      "end": 1711096856106,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1711096856106,
      "end": 1711096856109,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1711096856109,
      "end": 1711096856109,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1711096856109,
      "end": 1711096856109,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1711096856109,
      "end": 1711096856109,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1711096856109,
      "end": 1711096856109,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1711096856110,
      "end": 1711096856110,
      "order": "normal"
    }
  ]
}
