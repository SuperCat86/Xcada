{
  "resolvedId": "D:/Project/Project/project-front/vue-user-template-new/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DragAndDropData, StaticDND } from '../../dnd.js';\nimport { $, addDisposableListener, append, clearNode, createStyleSheet, getDomNodePagePosition, hasParentWithClass } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { DefaultKeyboardNavigationDelegate, isInputElement, isMonacoEditor, List, MouseController } from '../list/listWidget.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { distinct, equals, range } from '../../../common/arrays.js';\nimport { disposableTimeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { SetMap } from '../../../common/collections.js';\nimport { Emitter, Event, EventBufferer, Relay } from '../../../common/event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { isMacintosh } from '../../../common/platform.js';\nimport './media/tree.css';\nimport { localize } from '../../../../nls.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new TreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass TreeNodeListDragAndDrop {\n    constructor(modelProvider, dnd) {\n        this.modelProvider = modelProvider;\n        this.dnd = dnd;\n        this.autoExpandDisposable = Disposable.None;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n        const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n        if (didChangeAutoExpandNode) {\n            this.autoExpandDisposable.dispose();\n            this.autoExpandNode = targetNode;\n        }\n        if (typeof targetNode === 'undefined') {\n            return result;\n        }\n        if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n            this.autoExpandDisposable = disposableTimeout(() => {\n                const model = this.modelProvider();\n                const ref = model.getNodeLocation(targetNode);\n                if (model.isCollapsed(ref)) {\n                    model.setCollapsed(ref, false);\n                }\n                this.autoExpandNode = undefined;\n            }, 500);\n        }\n        if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n            if (!raw) {\n                const accept = typeof result === 'boolean' ? result : result.accept;\n                const effect = typeof result === 'boolean' ? undefined : result.effect;\n                return { accept, effect, feedback: [targetIndex] };\n            }\n            return result;\n        }\n        if (result.bubble === 1 /* Up */) {\n            const model = this.modelProvider();\n            const ref = model.getNodeLocation(targetNode);\n            const parentRef = model.getParentNodeLocation(ref);\n            const parentNode = model.getNode(parentRef);\n            const parentIndex = parentRef && model.getListIndex(parentRef);\n            return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);\n        }\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        const start = model.getListIndex(ref);\n        const length = model.getListRenderCount(ref);\n        return Object.assign(Object.assign({}, result), { feedback: range(start, start + length) });\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.autoExpandDisposable.dispose();\n        this.autoExpandNode = undefined;\n        this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asListOptions(modelProvider, options) {\n    return options && Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getSetSize(node) {\n                const model = modelProvider();\n                const ref = model.getNodeLocation(node);\n                const parentRef = model.getParentNodeLocation(ref);\n                const parentNode = model.getNode(parentRef);\n                return parentNode.visibleChildrenCount;\n            },\n            getPosInSet(node) {\n                return node.visibleChildIndex + 1;\n            }, isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {\n                return options.accessibilityProvider.isChecked(node.element);\n            } : undefined, getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {\n                return options.accessibilityProvider.getRole(node.element);\n            } : () => 'treeitem', getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {\n                return node.depth;\n            }, getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(node) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n            } }), enableKeyboardNavigation: options.simpleKeyboardNavigation });\n}\nexport class ComposedTreeDelegate {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n    getHeight(element) {\n        return this.delegate.getHeight(element.element);\n    }\n    getTemplateId(element) {\n        return this.delegate.getTemplateId(element.element);\n    }\n    hasDynamicHeight(element) {\n        return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n    }\n    setDynamicHeight(element, height) {\n        if (this.delegate.setDynamicHeight) {\n            this.delegate.setDynamicHeight(element.element, height);\n        }\n    }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n    RenderIndentGuides[\"None\"] = \"none\";\n    RenderIndentGuides[\"OnHover\"] = \"onHover\";\n    RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n    constructor(onDidChange, _elements = []) {\n        this._elements = _elements;\n        this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements);\n    }\n    get elements() {\n        return this._elements;\n    }\n}\nclass TreeRenderer {\n    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n        this.activeNodes = activeNodes;\n        this.renderedElements = new Map();\n        this.renderedNodes = new Map();\n        this.indent = TreeRenderer.DefaultIndent;\n        this.hideTwistiesOfChildlessElements = false;\n        this.shouldRenderIndentGuides = false;\n        this.renderedIndentGuides = new SetMap();\n        this.activeIndentNodes = new Set();\n        this.indentGuidesDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n        this.templateId = renderer.templateId;\n        this.updateOptions(options);\n        Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n        if (renderer.onDidChangeTwistieState) {\n            renderer.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);\n        }\n    }\n    updateOptions(options = {}) {\n        if (typeof options.indent !== 'undefined') {\n            this.indent = clamp(options.indent, 0, 40);\n        }\n        if (typeof options.renderIndentGuides !== 'undefined') {\n            const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n            if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n                this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n                this.indentGuidesDisposable.dispose();\n                if (shouldRenderIndentGuides) {\n                    const disposables = new DisposableStore();\n                    this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n                    this.indentGuidesDisposable = disposables;\n                    this._onDidChangeActiveNodes(this.activeNodes.elements);\n                }\n            }\n        }\n        if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n            this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n        }\n    }\n    renderTemplate(container) {\n        const el = append(container, $('.monaco-tl-row'));\n        const indent = append(el, $('.monaco-tl-indent'));\n        const twistie = append(el, $('.monaco-tl-twistie'));\n        const contents = append(el, $('.monaco-tl-contents'));\n        const templateData = this.renderer.renderTemplate(contents);\n        return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        if (typeof height === 'number') {\n            this.renderedNodes.set(node, { templateData, height });\n            this.renderedElements.set(node.element, node);\n        }\n        const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n        templateData.twistie.style.paddingLeft = `${indent}px`;\n        templateData.indent.style.width = `${indent + this.indent - 16}px`;\n        this.renderTwistie(node, templateData);\n        if (typeof height === 'number') {\n            this.renderIndentGuides(node, templateData);\n        }\n        this.renderer.renderElement(node, index, templateData.templateData, height);\n    }\n    disposeElement(node, index, templateData, height) {\n        templateData.indentGuidesDisposable.dispose();\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(node, index, templateData.templateData, height);\n        }\n        if (typeof height === 'number') {\n            this.renderedNodes.delete(node);\n            this.renderedElements.delete(node.element);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    onDidChangeTwistieState(element) {\n        const node = this.renderedElements.get(element);\n        if (!node) {\n            return;\n        }\n        this.onDidChangeNodeTwistieState(node);\n    }\n    onDidChangeNodeTwistieState(node) {\n        const data = this.renderedNodes.get(node);\n        if (!data) {\n            return;\n        }\n        this.renderTwistie(node, data.templateData);\n        this._onDidChangeActiveNodes(this.activeNodes.elements);\n        this.renderIndentGuides(node, data.templateData);\n    }\n    renderTwistie(node, templateData) {\n        templateData.twistie.classList.remove(...Codicon.treeItemExpanded.classNamesArray);\n        let twistieRendered = false;\n        if (this.renderer.renderTwistie) {\n            twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n        }\n        if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n            if (!twistieRendered) {\n                templateData.twistie.classList.add(...Codicon.treeItemExpanded.classNamesArray);\n            }\n            templateData.twistie.classList.add('collapsible');\n            templateData.twistie.classList.toggle('collapsed', node.collapsed);\n        }\n        else {\n            templateData.twistie.classList.remove('collapsible', 'collapsed');\n        }\n        if (node.collapsible) {\n            templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n        }\n        else {\n            templateData.container.removeAttribute('aria-expanded');\n        }\n    }\n    renderIndentGuides(target, templateData) {\n        clearNode(templateData.indent);\n        templateData.indentGuidesDisposable.dispose();\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const disposableStore = new DisposableStore();\n        const model = this.modelProvider();\n        let node = target;\n        while (true) {\n            const ref = model.getNodeLocation(node);\n            const parentRef = model.getParentNodeLocation(ref);\n            if (!parentRef) {\n                break;\n            }\n            const parent = model.getNode(parentRef);\n            const guide = $('.indent-guide', { style: `width: ${this.indent}px` });\n            if (this.activeIndentNodes.has(parent)) {\n                guide.classList.add('active');\n            }\n            if (templateData.indent.childElementCount === 0) {\n                templateData.indent.appendChild(guide);\n            }\n            else {\n                templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n            }\n            this.renderedIndentGuides.add(parent, guide);\n            disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n            node = parent;\n        }\n        templateData.indentGuidesDisposable = disposableStore;\n    }\n    _onDidChangeActiveNodes(nodes) {\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const set = new Set();\n        const model = this.modelProvider();\n        nodes.forEach(node => {\n            const ref = model.getNodeLocation(node);\n            try {\n                const parentRef = model.getParentNodeLocation(ref);\n                if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n                    set.add(node);\n                }\n                else if (parentRef) {\n                    set.add(model.getNode(parentRef));\n                }\n            }\n            catch (_a) {\n                // noop\n            }\n        });\n        this.activeIndentNodes.forEach(node => {\n            if (!set.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n            }\n        });\n        set.forEach(node => {\n            if (!this.activeIndentNodes.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n            }\n        });\n        this.activeIndentNodes = set;\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.renderedElements.clear();\n        this.indentGuidesDisposable.dispose();\n        dispose(this.disposables);\n    }\n}\nTreeRenderer.DefaultIndent = 8;\nclass TypeFilter {\n    constructor(tree, keyboardNavigationLabelProvider, _filter) {\n        this.tree = tree;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this._filter = _filter;\n        this._totalCount = 0;\n        this._matchCount = 0;\n        this._pattern = '';\n        this._lowercasePattern = '';\n        this.disposables = new DisposableStore();\n        tree.onWillRefilter(this.reset, this, this.disposables);\n    }\n    get totalCount() { return this._totalCount; }\n    get matchCount() { return this._matchCount; }\n    set pattern(pattern) {\n        this._pattern = pattern;\n        this._lowercasePattern = pattern.toLowerCase();\n    }\n    filter(element, parentVisibility) {\n        if (this._filter) {\n            const result = this._filter.filter(element, parentVisibility);\n            if (this.tree.options.simpleKeyboardNavigation) {\n                return result;\n            }\n            let visibility;\n            if (typeof result === 'boolean') {\n                visibility = result ? 1 /* Visible */ : 0 /* Hidden */;\n            }\n            else if (isFilterResult(result)) {\n                visibility = getVisibleState(result.visibility);\n            }\n            else {\n                visibility = result;\n            }\n            if (visibility === 0 /* Hidden */) {\n                return false;\n            }\n        }\n        this._totalCount++;\n        if (this.tree.options.simpleKeyboardNavigation || !this._pattern) {\n            this._matchCount++;\n            return { data: FuzzyScore.Default, visibility: true };\n        }\n        const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n        const labels = Array.isArray(label) ? label : [label];\n        for (const l of labels) {\n            const labelStr = l && l.toString();\n            if (typeof labelStr === 'undefined') {\n                return { data: FuzzyScore.Default, visibility: true };\n            }\n            const score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, true);\n            if (score) {\n                this._matchCount++;\n                return labels.length === 1 ?\n                    { data: score, visibility: true } :\n                    { data: { label: labelStr, score: score }, visibility: true };\n            }\n        }\n        if (this.tree.options.filterOnType) {\n            return 2 /* Recurse */;\n        }\n        else {\n            return { data: FuzzyScore.Default, visibility: true };\n        }\n    }\n    reset() {\n        this._totalCount = 0;\n        this._matchCount = 0;\n    }\n    dispose() {\n        dispose(this.disposables);\n    }\n}\nclass TypeFilterController {\n    constructor(tree, model, view, filter, keyboardNavigationDelegate) {\n        this.tree = tree;\n        this.view = view;\n        this.filter = filter;\n        this.keyboardNavigationDelegate = keyboardNavigationDelegate;\n        this._enabled = false;\n        this._pattern = '';\n        this._empty = false;\n        this._onDidChangeEmptyState = new Emitter();\n        this.positionClassName = 'ne';\n        this.automaticKeyboardNavigation = true;\n        this.triggered = false;\n        this._onDidChangePattern = new Emitter();\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this.domNode = $(`.monaco-list-type-filter.${this.positionClassName}`);\n        this.domNode.draggable = true;\n        this.disposables.add(addDisposableListener(this.domNode, 'dragstart', () => this.onDragStart()));\n        this.messageDomNode = append(view.getHTMLElement(), $(`.monaco-list-type-filter-message`));\n        this.labelDomNode = append(this.domNode, $('span.label'));\n        const controls = append(this.domNode, $('.controls'));\n        this._filterOnType = !!tree.options.filterOnType;\n        this.filterOnTypeDomNode = append(controls, $('input.filter'));\n        this.filterOnTypeDomNode.type = 'checkbox';\n        this.filterOnTypeDomNode.checked = this._filterOnType;\n        this.filterOnTypeDomNode.tabIndex = -1;\n        this.updateFilterOnTypeTitleAndIcon();\n        this.disposables.add(addDisposableListener(this.filterOnTypeDomNode, 'input', () => this.onDidChangeFilterOnType()));\n        this.clearDomNode = append(controls, $('button.clear' + Codicon.treeFilterClear.cssSelector));\n        this.clearDomNode.tabIndex = -1;\n        this.clearDomNode.title = localize('clear', \"Clear\");\n        this.keyboardNavigationEventFilter = tree.options.keyboardNavigationEventFilter;\n        model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n        this.updateOptions(tree.options);\n    }\n    get enabled() { return this._enabled; }\n    get pattern() { return this._pattern; }\n    get filterOnType() { return this._filterOnType; }\n    updateOptions(options) {\n        if (options.simpleKeyboardNavigation) {\n            this.disable();\n        }\n        else {\n            this.enable();\n        }\n        if (typeof options.filterOnType !== 'undefined') {\n            this._filterOnType = !!options.filterOnType;\n            this.filterOnTypeDomNode.checked = this._filterOnType;\n            this.updateFilterOnTypeTitleAndIcon();\n        }\n        if (typeof options.automaticKeyboardNavigation !== 'undefined') {\n            this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;\n        }\n        this.tree.refilter();\n        this.render();\n        if (!this.automaticKeyboardNavigation) {\n            this.onEventOrInput('');\n        }\n    }\n    enable() {\n        if (this._enabled) {\n            return;\n        }\n        const onRawKeyDown = this.enabledDisposables.add(new DomEmitter(this.view.getHTMLElement(), 'keydown'));\n        const onKeyDown = Event.chain(onRawKeyDown.event)\n            .filter(e => !isInputElement(e.target) || e.target === this.filterOnTypeDomNode)\n            .filter(e => e.key !== 'Dead' && !/^Media/.test(e.key))\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(this.keyboardNavigationEventFilter || (() => true))\n            .filter(() => this.automaticKeyboardNavigation || this.triggered)\n            .filter(e => (this.keyboardNavigationDelegate.mightProducePrintableCharacter(e) && !(e.keyCode === 18 /* DownArrow */ || e.keyCode === 16 /* UpArrow */ || e.keyCode === 15 /* LeftArrow */ || e.keyCode === 17 /* RightArrow */)) || ((this.pattern.length > 0 || this.triggered) && ((e.keyCode === 9 /* Escape */ || e.keyCode === 1 /* Backspace */) && !e.altKey && !e.ctrlKey && !e.metaKey) || (e.keyCode === 1 /* Backspace */ && (isMacintosh ? (e.altKey && !e.metaKey) : e.ctrlKey) && !e.shiftKey)))\n            .forEach(e => { e.stopPropagation(); e.preventDefault(); })\n            .event;\n        const onClearClick = this.enabledDisposables.add(new DomEmitter(this.clearDomNode, 'click'));\n        Event.chain(Event.any(onKeyDown, onClearClick.event))\n            .event(this.onEventOrInput, this, this.enabledDisposables);\n        this.filter.pattern = '';\n        this.tree.refilter();\n        this.render();\n        this._enabled = true;\n        this.triggered = false;\n    }\n    disable() {\n        if (!this._enabled) {\n            return;\n        }\n        this.domNode.remove();\n        this.enabledDisposables.clear();\n        this.tree.refilter();\n        this.render();\n        this._enabled = false;\n        this.triggered = false;\n    }\n    onEventOrInput(e) {\n        if (typeof e === 'string') {\n            this.onInput(e);\n        }\n        else if (e instanceof MouseEvent || e.keyCode === 9 /* Escape */ || (e.keyCode === 1 /* Backspace */ && (isMacintosh ? e.altKey : e.ctrlKey))) {\n            this.onInput('');\n        }\n        else if (e.keyCode === 1 /* Backspace */) {\n            this.onInput(this.pattern.length === 0 ? '' : this.pattern.substr(0, this.pattern.length - 1));\n        }\n        else {\n            this.onInput(this.pattern + e.browserEvent.key);\n        }\n    }\n    onInput(pattern) {\n        const container = this.view.getHTMLElement();\n        if (pattern && !this.domNode.parentElement) {\n            container.append(this.domNode);\n        }\n        else if (!pattern && this.domNode.parentElement) {\n            this.domNode.remove();\n            this.tree.domFocus();\n        }\n        this._pattern = pattern;\n        this._onDidChangePattern.fire(pattern);\n        this.filter.pattern = pattern;\n        this.tree.refilter();\n        if (pattern) {\n            this.tree.focusNext(0, true, undefined, node => !FuzzyScore.isDefault(node.filterData));\n        }\n        const focus = this.tree.getFocus();\n        if (focus.length > 0) {\n            const element = focus[0];\n            if (this.tree.getRelativeTop(element) === null) {\n                this.tree.reveal(element, 0.5);\n            }\n        }\n        this.render();\n        if (!pattern) {\n            this.triggered = false;\n        }\n    }\n    onDragStart() {\n        const container = this.view.getHTMLElement();\n        const { left } = getDomNodePagePosition(container);\n        const containerWidth = container.clientWidth;\n        const midContainerWidth = containerWidth / 2;\n        const width = this.domNode.clientWidth;\n        const disposables = new DisposableStore();\n        let positionClassName = this.positionClassName;\n        const updatePosition = () => {\n            switch (positionClassName) {\n                case 'nw':\n                    this.domNode.style.top = `4px`;\n                    this.domNode.style.left = `4px`;\n                    break;\n                case 'ne':\n                    this.domNode.style.top = `4px`;\n                    this.domNode.style.left = `${containerWidth - width - 6}px`;\n                    break;\n            }\n        };\n        const onDragOver = (event) => {\n            event.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n            const x = event.clientX - left;\n            if (event.dataTransfer) {\n                event.dataTransfer.dropEffect = 'none';\n            }\n            if (x < midContainerWidth) {\n                positionClassName = 'nw';\n            }\n            else {\n                positionClassName = 'ne';\n            }\n            updatePosition();\n        };\n        const onDragEnd = () => {\n            this.positionClassName = positionClassName;\n            this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`;\n            this.domNode.style.top = '';\n            this.domNode.style.left = '';\n            dispose(disposables);\n        };\n        updatePosition();\n        this.domNode.classList.remove(positionClassName);\n        this.domNode.classList.add('dragging');\n        disposables.add(toDisposable(() => this.domNode.classList.remove('dragging')));\n        disposables.add(addDisposableListener(document, 'dragover', e => onDragOver(e)));\n        disposables.add(addDisposableListener(this.domNode, 'dragend', () => onDragEnd()));\n        StaticDND.CurrentDragAndDropData = new DragAndDropData('vscode-ui');\n        disposables.add(toDisposable(() => StaticDND.CurrentDragAndDropData = undefined));\n    }\n    onDidSpliceModel() {\n        if (!this._enabled || this.pattern.length === 0) {\n            return;\n        }\n        this.tree.refilter();\n        this.render();\n    }\n    onDidChangeFilterOnType() {\n        this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked });\n        this.tree.refilter();\n        this.tree.domFocus();\n        this.render();\n        this.updateFilterOnTypeTitleAndIcon();\n    }\n    updateFilterOnTypeTitleAndIcon() {\n        if (this.filterOnType) {\n            this.filterOnTypeDomNode.classList.remove(...Codicon.treeFilterOnTypeOff.classNamesArray);\n            this.filterOnTypeDomNode.classList.add(...Codicon.treeFilterOnTypeOn.classNamesArray);\n            this.filterOnTypeDomNode.title = localize('disable filter on type', \"Disable Filter on Type\");\n        }\n        else {\n            this.filterOnTypeDomNode.classList.remove(...Codicon.treeFilterOnTypeOn.classNamesArray);\n            this.filterOnTypeDomNode.classList.add(...Codicon.treeFilterOnTypeOff.classNamesArray);\n            this.filterOnTypeDomNode.title = localize('enable filter on type', \"Enable Filter on Type\");\n        }\n    }\n    render() {\n        const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n        if (this.pattern && this.tree.options.filterOnType && noMatches) {\n            this.messageDomNode.textContent = localize('empty', \"No elements found\");\n            this._empty = true;\n        }\n        else {\n            this.messageDomNode.innerText = '';\n            this._empty = false;\n        }\n        this.domNode.classList.toggle('no-matches', noMatches);\n        this.domNode.title = localize('found', \"Matched {0} out of {1} elements\", this.filter.matchCount, this.filter.totalCount);\n        this.labelDomNode.textContent = this.pattern.length > 16 ? 'â€¦' + this.pattern.substr(this.pattern.length - 16) : this.pattern;\n        this._onDidChangeEmptyState.fire(this._empty);\n    }\n    shouldAllowFocus(node) {\n        if (!this.enabled || !this.pattern || this.filterOnType) {\n            return true;\n        }\n        if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n            return true;\n        }\n        return !FuzzyScore.isDefault(node.filterData);\n    }\n    dispose() {\n        if (this._enabled) {\n            this.domNode.remove();\n            this.enabledDisposables.dispose();\n            this._enabled = false;\n            this.triggered = false;\n        }\n        this._onDidChangePattern.dispose();\n        dispose(this.disposables);\n    }\n}\nfunction asTreeMouseEvent(event) {\n    let target = TreeMouseEventTarget.Unknown;\n    if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Twistie;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Element;\n    }\n    return {\n        browserEvent: event.browserEvent,\n        element: event.element ? event.element.element : null,\n        target\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n    constructor(getFirstViewElementWithTrait, identityProvider) {\n        this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;\n        this.identityProvider = identityProvider;\n        this.nodes = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    get nodeSet() {\n        if (!this._nodeSet) {\n            this._nodeSet = this.createNodeSet();\n        }\n        return this._nodeSet;\n    }\n    set(nodes, browserEvent) {\n        if (!(browserEvent === null || browserEvent === void 0 ? void 0 : browserEvent.__forceEvent) && equals(this.nodes, nodes)) {\n            return;\n        }\n        this._set(nodes, false, browserEvent);\n    }\n    _set(nodes, silent, browserEvent) {\n        this.nodes = [...nodes];\n        this.elements = undefined;\n        this._nodeSet = undefined;\n        if (!silent) {\n            const that = this;\n            this._onDidChange.fire({ get elements() { return that.get(); }, browserEvent });\n        }\n    }\n    get() {\n        if (!this.elements) {\n            this.elements = this.nodes.map(node => node.element);\n        }\n        return [...this.elements];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    has(node) {\n        return this.nodeSet.has(node);\n    }\n    onDidModelSplice({ insertedNodes, deletedNodes }) {\n        if (!this.identityProvider) {\n            const set = this.createNodeSet();\n            const visit = (node) => set.delete(node);\n            deletedNodes.forEach(node => dfs(node, visit));\n            this.set([...set.values()]);\n            return;\n        }\n        const deletedNodesIdSet = new Set();\n        const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n        const insertedNodesMap = new Map();\n        const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n        const nodes = [];\n        for (const node of this.nodes) {\n            const id = this.identityProvider.getId(node.element).toString();\n            const wasDeleted = deletedNodesIdSet.has(id);\n            if (!wasDeleted) {\n                nodes.push(node);\n            }\n            else {\n                const insertedNode = insertedNodesMap.get(id);\n                if (insertedNode) {\n                    nodes.push(insertedNode);\n                }\n            }\n        }\n        if (this.nodes.length > 0 && nodes.length === 0) {\n            const node = this.getFirstViewElementWithTrait();\n            if (node) {\n                nodes.push(node);\n            }\n        }\n        this._set(nodes, true);\n    }\n    createNodeSet() {\n        const set = new Set();\n        for (const node of this.nodes) {\n            set.add(node);\n        }\n        return set;\n    }\n}\nclass TreeNodeListMouseController extends MouseController {\n    constructor(list, tree) {\n        super(list);\n        this.tree = tree;\n    }\n    onViewPointer(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const node = e.element;\n        if (!node) {\n            return super.onViewPointer(e);\n        }\n        if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n            return super.onViewPointer(e);\n        }\n        const target = e.browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16);\n        let expandOnlyOnTwistieClick = false;\n        if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n            expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n        }\n        else {\n            expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n        }\n        if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n            return super.onViewPointer(e);\n        }\n        if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n            return super.onViewPointer(e);\n        }\n        if (node.collapsible) {\n            const model = this.tree.model; // internal\n            const location = model.getNodeLocation(node);\n            const recursive = e.browserEvent.altKey;\n            this.tree.setFocus([location]);\n            model.setCollapsed(location, undefined, recursive);\n            if (expandOnlyOnTwistieClick && onTwistie) {\n                return;\n            }\n        }\n        super.onViewPointer(e);\n    }\n    onDoubleClick(e) {\n        const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n        if (onTwistie || !this.tree.expandOnDoubleClick) {\n            return;\n        }\n        super.onDoubleClick(e);\n    }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n        super(user, container, virtualDelegate, renderers, options);\n        this.focusTrait = focusTrait;\n        this.selectionTrait = selectionTrait;\n        this.anchorTrait = anchorTrait;\n    }\n    createMouseController(options) {\n        return new TreeNodeListMouseController(this, options.tree);\n    }\n    splice(start, deleteCount, elements = []) {\n        super.splice(start, deleteCount, elements);\n        if (elements.length === 0) {\n            return;\n        }\n        const additionalFocus = [];\n        const additionalSelection = [];\n        let anchor;\n        elements.forEach((node, index) => {\n            if (this.focusTrait.has(node)) {\n                additionalFocus.push(start + index);\n            }\n            if (this.selectionTrait.has(node)) {\n                additionalSelection.push(start + index);\n            }\n            if (this.anchorTrait.has(node)) {\n                anchor = start + index;\n            }\n        });\n        if (additionalFocus.length > 0) {\n            super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));\n        }\n        if (additionalSelection.length > 0) {\n            super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));\n        }\n        if (typeof anchor === 'number') {\n            super.setAnchor(anchor);\n        }\n    }\n    setFocus(indexes, browserEvent, fromAPI = false) {\n        super.setFocus(indexes, browserEvent);\n        if (!fromAPI) {\n            this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setSelection(indexes, browserEvent, fromAPI = false) {\n        super.setSelection(indexes, browserEvent);\n        if (!fromAPI) {\n            this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setAnchor(index, fromAPI = false) {\n        super.setAnchor(index);\n        if (!fromAPI) {\n            if (typeof index === 'undefined') {\n                this.anchorTrait.set([]);\n            }\n            else {\n                this.anchorTrait.set([this.element(index)]);\n            }\n        }\n    }\n}\nexport class AbstractTree {\n    constructor(_user, container, delegate, renderers, _options = {}) {\n        this._user = _user;\n        this._options = _options;\n        this.eventBufferer = new EventBufferer();\n        this.disposables = new DisposableStore();\n        this._onWillRefilter = new Emitter();\n        this.onWillRefilter = this._onWillRefilter.event;\n        this._onDidUpdateOptions = new Emitter();\n        const treeDelegate = new ComposedTreeDelegate(delegate);\n        const onDidChangeCollapseStateRelay = new Relay();\n        const onDidChangeActiveNodes = new Relay();\n        const activeNodes = new EventCollection(onDidChangeActiveNodes.event);\n        this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));\n        for (let r of this.renderers) {\n            this.disposables.add(r);\n        }\n        let filter;\n        if (_options.keyboardNavigationLabelProvider) {\n            filter = new TypeFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n            _options = Object.assign(Object.assign({}, _options), { filter: filter }); // TODO need typescript help here\n            this.disposables.add(filter);\n        }\n        this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);\n        this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);\n        this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);\n        this.view = new TreeNodeList(_user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), { tree: this }));\n        this.model = this.createModel(_user, this.view, _options);\n        onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n        const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n            this.eventBufferer.bufferEvents(() => {\n                this.focus.onDidModelSplice(e);\n                this.selection.onDidModelSplice(e);\n            });\n        });\n        // Make sure the `forEach` always runs\n        onDidModelSplice(() => null, null, this.disposables);\n        // Active nodes can change when the model changes or when focus or selection change.\n        // We debounce it with 0 delay since these events may fire in the same stack and we only\n        // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n        // a nice to have UI feature.\n        onDidChangeActiveNodes.input = Event.chain(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange))\n            .debounce(() => null, 0)\n            .map(() => {\n            const set = new Set();\n            for (const node of this.focus.getNodes()) {\n                set.add(node);\n            }\n            for (const node of this.selection.getNodes()) {\n                set.add(node);\n            }\n            return [...set.values()];\n        }).event;\n        if (_options.keyboardSupport !== false) {\n            const onKeyDown = Event.chain(this.view.onKeyDown)\n                .filter(e => !isInputElement(e.target))\n                .map(e => new StandardKeyboardEvent(e));\n            onKeyDown.filter(e => e.keyCode === 15 /* LeftArrow */).on(this.onLeftArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 17 /* RightArrow */).on(this.onRightArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 10 /* Space */).on(this.onSpace, this, this.disposables);\n        }\n        if (_options.keyboardNavigationLabelProvider) {\n            const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;\n            this.typeFilterController = new TypeFilterController(this, this.model, this.view, filter, delegate);\n            this.focusNavigationFilter = node => this.typeFilterController.shouldAllowFocus(node);\n            this.disposables.add(this.typeFilterController);\n        }\n        this.styleElement = createStyleSheet(this.view.getHTMLElement());\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }\n    get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }\n    get onMouseDblClick() { return Event.map(this.view.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.view.onDidFocus; }\n    get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }\n    get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }\n    get onDidDispose() { return this.view.onDidDispose; }\n    updateOptions(optionsUpdate = {}) {\n        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);\n        for (const renderer of this.renderers) {\n            renderer.updateOptions(optionsUpdate);\n        }\n        this.view.updateOptions(Object.assign(Object.assign({}, this._options), { enableKeyboardNavigation: this._options.simpleKeyboardNavigation }));\n        if (this.typeFilterController) {\n            this.typeFilterController.updateOptions(this._options);\n        }\n        this._onDidUpdateOptions.fire(this._options);\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get options() {\n        return this._options;\n    }\n    // Widget\n    getHTMLElement() {\n        return this.view.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.view.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.view.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.view.domFocus();\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n    }\n    style(styles) {\n        const suffix = `.${this.view.domId}`;\n        const content = [];\n        if (styles.treeIndentGuidesStroke) {\n            content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);\n            content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n        this.view.style(styles);\n    }\n    // Tree navigation\n    getParentElement(location) {\n        const parentRef = this.model.getParentNodeLocation(location);\n        const parentNode = this.model.getNode(parentRef);\n        return parentNode.element;\n    }\n    getFirstElementChild(location) {\n        return this.model.getFirstElementChild(location);\n    }\n    // Tree\n    getNode(location) {\n        return this.model.getNode(location);\n    }\n    collapse(location, recursive = false) {\n        return this.model.setCollapsed(location, true, recursive);\n    }\n    expand(location, recursive = false) {\n        return this.model.setCollapsed(location, false, recursive);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsible) {\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    refilter() {\n        this._onWillRefilter.fire(undefined);\n        this.model.refilter();\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.selection.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setSelection(indexes, browserEvent, true);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.focus.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setFocus(indexes, browserEvent, true);\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {\n        this.view.focusNext(n, loop, browserEvent, filter);\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    reveal(location, relativeTop) {\n        this.model.expandTo(location);\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return;\n        }\n        this.view.reveal(index, relativeTop);\n    }\n    /**\n     * Returns the relative position of an element rendered in the list.\n     * Returns `null` if the element isn't *entirely* in the visible viewport.\n     */\n    getRelativeTop(location) {\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return null;\n        }\n        return this.view.getRelativeTop(index);\n    }\n    // List\n    onLeftArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, true);\n        if (!didChange) {\n            const parentLocation = this.model.getParentNodeLocation(location);\n            if (!parentLocation) {\n                return;\n            }\n            const parentListIndex = this.model.getListIndex(parentLocation);\n            this.view.reveal(parentListIndex);\n            this.view.setFocus([parentListIndex]);\n        }\n    }\n    onRightArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, false);\n        if (!didChange) {\n            if (!node.children.some(child => child.visible)) {\n                return;\n            }\n            const [focusedIndex] = this.view.getFocus();\n            const firstChildIndex = focusedIndex + 1;\n            this.view.reveal(firstChildIndex);\n            this.view.setFocus([firstChildIndex]);\n        }\n    }\n    onSpace(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const recursive = e.browserEvent.altKey;\n        this.model.setCollapsed(location, undefined, recursive);\n    }\n    dispose() {\n        dispose(this.disposables);\n        this.view.dispose();\n    }\n}\n",
      "start": 1711096857431,
      "end": 1711096857550,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1711096857550,
      "end": 1711096857550,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1711096857550,
      "end": 1711096857554,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1711096857554,
      "end": 1711096857554,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1711096857554,
      "end": 1711096857555,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1711096857555,
      "end": 1711096857555,
      "order": "normal"
    }
  ]
}
