{
  "resolvedId": "D:/Project/Project/project-front/vue-user-template-new/node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditorWidget.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar _a;\nimport './media/diffEditor.css';\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { Sash } from '../../../base/browser/ui/sash/sash.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { StableEditorScrollState } from '../stableEditorScroll.js';\nimport { ICodeEditorService } from '../services/codeEditorService.js';\nimport { CodeEditorWidget } from './codeEditorWidget.js';\nimport { DiffReview } from './diffReview.js';\nimport { EditorOptions, EditorFontLigatures, stringSet as validateStringSetOption, boolean as validateBooleanOption, clampedInt } from '../../common/config/editorOptions.js';\nimport { Range } from '../../common/core/range.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as editorCommon from '../../common/editorCommon.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { OverviewRulerZone } from '../../common/viewModel/overviewZoneManager.js';\nimport { LineDecoration } from '../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { InlineDecoration, ViewLineRenderingData } from '../../common/viewModel.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { defaultInsertColor, defaultRemoveColor, diffBorder, diffInserted, diffInsertedOutline, diffRemoved, diffRemovedOutline, scrollbarShadow, scrollbarSliderBackground, scrollbarSliderHoverBackground, scrollbarSliderActiveBackground, diffDiagonalFill, diffInsertedLineGutter, diffRemovedLineGutter, diffInsertedLine, diffRemovedLine, diffOverviewRulerInserted, diffOverviewRulerRemoved } from '../../../platform/theme/common/colorRegistry.js';\nimport { IThemeService, getThemeTypeSelector, registerThemingParticipant, ThemeIcon } from '../../../platform/theme/common/themeService.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { InlineDiffMargin } from './inlineDiffMargin.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { EditorExtensionsRegistry } from '../editorExtensions.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { ElementSizeObserver } from '../config/elementSizeObserver.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { registerIcon } from '../../../platform/theme/common/iconRegistry.js';\nclass VisualEditorState {\n    constructor(_contextMenuService, _clipboardService) {\n        this._contextMenuService = _contextMenuService;\n        this._clipboardService = _clipboardService;\n        this._zones = [];\n        this._inlineDiffMargins = [];\n        this._zonesMap = {};\n        this._decorations = [];\n    }\n    getForeignViewZones(allViewZones) {\n        return allViewZones.filter((z) => !this._zonesMap[String(z.id)]);\n    }\n    clean(editor) {\n        // (1) View zones\n        if (this._zones.length > 0) {\n            editor.changeViewZones((viewChangeAccessor) => {\n                for (const zoneId of this._zones) {\n                    viewChangeAccessor.removeZone(zoneId);\n                }\n            });\n        }\n        this._zones = [];\n        this._zonesMap = {};\n        // (2) Model decorations\n        this._decorations = editor.deltaDecorations(this._decorations, []);\n    }\n    apply(editor, overviewRuler, newDecorations, restoreScrollState) {\n        const scrollState = restoreScrollState ? StableEditorScrollState.capture(editor) : null;\n        // view zones\n        editor.changeViewZones((viewChangeAccessor) => {\n            var _a;\n            for (const zoneId of this._zones) {\n                viewChangeAccessor.removeZone(zoneId);\n            }\n            for (const inlineDiffMargin of this._inlineDiffMargins) {\n                inlineDiffMargin.dispose();\n            }\n            this._zones = [];\n            this._zonesMap = {};\n            this._inlineDiffMargins = [];\n            for (let i = 0, length = newDecorations.zones.length; i < length; i++) {\n                const viewZone = newDecorations.zones[i];\n                viewZone.suppressMouseDown = true;\n                const zoneId = viewChangeAccessor.addZone(viewZone);\n                this._zones.push(zoneId);\n                this._zonesMap[String(zoneId)] = true;\n                if (newDecorations.zones[i].diff && viewZone.marginDomNode) {\n                    viewZone.suppressMouseDown = false;\n                    if (((_a = newDecorations.zones[i].diff) === null || _a === void 0 ? void 0 : _a.originalModel.getValueLength()) !== 0) {\n                        // do not contribute diff margin actions for newly created files\n                        this._inlineDiffMargins.push(new InlineDiffMargin(zoneId, viewZone.marginDomNode, editor, newDecorations.zones[i].diff, this._contextMenuService, this._clipboardService));\n                    }\n                }\n            }\n        });\n        if (scrollState) {\n            scrollState.restore(editor);\n        }\n        // decorations\n        this._decorations = editor.deltaDecorations(this._decorations, newDecorations.decorations);\n        // overview ruler\n        if (overviewRuler) {\n            overviewRuler.setZones(newDecorations.overviewZones);\n        }\n    }\n}\nlet DIFF_EDITOR_ID = 0;\nconst diffInsertIcon = registerIcon('diff-insert', Codicon.add, nls.localize('diffInsertIcon', 'Line decoration for inserts in the diff editor.'));\nconst diffRemoveIcon = registerIcon('diff-remove', Codicon.remove, nls.localize('diffRemoveIcon', 'Line decoration for removals in the diff editor.'));\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('diffEditorWidget', { createHTML: value => value });\nlet DiffEditorWidget = class DiffEditorWidget extends Disposable {\n    constructor(domElement, options, codeEditorWidgetOptions, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, _editorProgressService) {\n        super();\n        this._editorProgressService = _editorProgressService;\n        this._onDidDispose = this._register(new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._onDidUpdateDiff = this._register(new Emitter());\n        this.onDidUpdateDiff = this._onDidUpdateDiff.event;\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this._lastOriginalWarning = null;\n        this._lastModifiedWarning = null;\n        this._editorWorkerService = editorWorkerService;\n        this._codeEditorService = codeEditorService;\n        this._contextKeyService = this._register(contextKeyService.createScoped(domElement));\n        this._instantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));\n        this._contextKeyService.createKey('isInDiffEditor', true);\n        this._themeService = themeService;\n        this._notificationService = notificationService;\n        this._id = (++DIFF_EDITOR_ID);\n        this._state = 0 /* Idle */;\n        this._updatingDiffProgress = null;\n        this._domElement = domElement;\n        options = options || {};\n        this._options = validateDiffEditorOptions(options, {\n            enableSplitViewResizing: true,\n            renderSideBySide: true,\n            maxComputationTime: 5000,\n            maxFileSize: 50,\n            ignoreTrimWhitespace: true,\n            renderIndicators: true,\n            originalEditable: false,\n            diffCodeLens: false,\n            renderOverviewRuler: true,\n            diffWordWrap: 'inherit'\n        });\n        if (typeof options.isInEmbeddedEditor !== 'undefined') {\n            this._contextKeyService.createKey('isInEmbeddedDiffEditor', options.isInEmbeddedEditor);\n        }\n        else {\n            this._contextKeyService.createKey('isInEmbeddedDiffEditor', false);\n        }\n        this._updateDecorationsRunner = this._register(new RunOnceScheduler(() => this._updateDecorations(), 0));\n        this._containerDomElement = document.createElement('div');\n        this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);\n        this._containerDomElement.style.position = 'relative';\n        this._containerDomElement.style.height = '100%';\n        this._domElement.appendChild(this._containerDomElement);\n        this._overviewViewportDomElement = createFastDomNode(document.createElement('div'));\n        this._overviewViewportDomElement.setClassName('diffViewport');\n        this._overviewViewportDomElement.setPosition('absolute');\n        this._overviewDomElement = document.createElement('div');\n        this._overviewDomElement.className = 'diffOverview';\n        this._overviewDomElement.style.position = 'absolute';\n        this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode);\n        this._register(dom.addStandardDisposableListener(this._overviewDomElement, 'mousedown', (e) => {\n            this._modifiedEditor.delegateVerticalScrollbarMouseDown(e);\n        }));\n        if (this._options.renderOverviewRuler) {\n            this._containerDomElement.appendChild(this._overviewDomElement);\n        }\n        // Create left side\n        this._originalDomNode = document.createElement('div');\n        this._originalDomNode.className = 'editor original';\n        this._originalDomNode.style.position = 'absolute';\n        this._originalDomNode.style.height = '100%';\n        this._containerDomElement.appendChild(this._originalDomNode);\n        // Create right side\n        this._modifiedDomNode = document.createElement('div');\n        this._modifiedDomNode.className = 'editor modified';\n        this._modifiedDomNode.style.position = 'absolute';\n        this._modifiedDomNode.style.height = '100%';\n        this._containerDomElement.appendChild(this._modifiedDomNode);\n        this._beginUpdateDecorationsTimeout = -1;\n        this._currentlyChangingViewZones = false;\n        this._diffComputationToken = 0;\n        this._originalEditorState = new VisualEditorState(contextMenuService, clipboardService);\n        this._modifiedEditorState = new VisualEditorState(contextMenuService, clipboardService);\n        this._isVisible = true;\n        this._isHandlingScrollEvent = false;\n        this._elementSizeObserver = this._register(new ElementSizeObserver(this._containerDomElement, options.dimension));\n        this._register(this._elementSizeObserver.onDidChange(() => this._onDidContainerSizeChanged()));\n        if (options.automaticLayout) {\n            this._elementSizeObserver.startObserving();\n        }\n        this._diffComputationResult = null;\n        this._originalEditor = this._createLeftHandSideEditor(options, codeEditorWidgetOptions.originalEditor || {});\n        this._modifiedEditor = this._createRightHandSideEditor(options, codeEditorWidgetOptions.modifiedEditor || {});\n        this._originalOverviewRuler = null;\n        this._modifiedOverviewRuler = null;\n        this._reviewPane = instantiationService.createInstance(DiffReview, this);\n        this._containerDomElement.appendChild(this._reviewPane.domNode.domNode);\n        this._containerDomElement.appendChild(this._reviewPane.shadow.domNode);\n        this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode);\n        if (this._options.renderSideBySide) {\n            this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._options.enableSplitViewResizing));\n        }\n        else {\n            this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._options.enableSplitViewResizing));\n        }\n        this._register(themeService.onDidColorThemeChange(t => {\n            if (this._strategy && this._strategy.applyColors(t)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);\n        }));\n        const contributions = EditorExtensionsRegistry.getDiffEditorContributions();\n        for (const desc of contributions) {\n            try {\n                this._register(instantiationService.createInstance(desc.ctor, this));\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        this._codeEditorService.addDiffEditor(this);\n    }\n    _setState(newState) {\n        if (this._state === newState) {\n            return;\n        }\n        this._state = newState;\n        if (this._updatingDiffProgress) {\n            this._updatingDiffProgress.done();\n            this._updatingDiffProgress = null;\n        }\n        if (this._state === 1 /* ComputingDiff */) {\n            this._updatingDiffProgress = this._editorProgressService.show(true, 1000);\n        }\n    }\n    diffReviewNext() {\n        this._reviewPane.next();\n    }\n    diffReviewPrev() {\n        this._reviewPane.prev();\n    }\n    static _getClassName(theme, renderSideBySide) {\n        let result = 'monaco-diff-editor monaco-editor-background ';\n        if (renderSideBySide) {\n            result += 'side-by-side ';\n        }\n        result += getThemeTypeSelector(theme.type);\n        return result;\n    }\n    _recreateOverviewRulers() {\n        if (!this._options.renderOverviewRuler) {\n            return;\n        }\n        if (this._originalOverviewRuler) {\n            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());\n            this._originalOverviewRuler.dispose();\n        }\n        if (this._originalEditor.hasModel()) {\n            this._originalOverviewRuler = this._originalEditor.createOverviewRuler('original diffOverviewRuler');\n            this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());\n        }\n        if (this._modifiedOverviewRuler) {\n            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());\n            this._modifiedOverviewRuler.dispose();\n        }\n        if (this._modifiedEditor.hasModel()) {\n            this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler('modified diffOverviewRuler');\n            this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());\n        }\n        this._layoutOverviewRulers();\n    }\n    _createLeftHandSideEditor(options, codeEditorWidgetOptions) {\n        const editor = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options), codeEditorWidgetOptions);\n        this._register(editor.onDidScrollChange((e) => {\n            if (this._isHandlingScrollEvent) {\n                return;\n            }\n            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {\n                return;\n            }\n            this._isHandlingScrollEvent = true;\n            this._modifiedEditor.setScrollPosition({\n                scrollLeft: e.scrollLeft,\n                scrollTop: e.scrollTop\n            });\n            this._isHandlingScrollEvent = false;\n            this._layoutOverviewViewport();\n        }));\n        this._register(editor.onDidChangeViewZones(() => {\n            this._onViewZonesChanged();\n        }));\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (!editor.getModel()) {\n                return;\n            }\n            if (e.hasChanged(44 /* fontInfo */)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            if (e.hasChanged(132 /* wrappingInfo */)) {\n                this._updateDecorationsRunner.cancel();\n                this._updateDecorations();\n            }\n        }));\n        this._register(editor.onDidChangeHiddenAreas(() => {\n            this._updateDecorationsRunner.cancel();\n            this._updateDecorations();\n        }));\n        this._register(editor.onDidChangeModelContent(() => {\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }));\n        const isInDiffLeftEditorKey = this._contextKeyService.createKey('isInDiffLeftEditor', editor.hasWidgetFocus());\n        this._register(editor.onDidFocusEditorWidget(() => isInDiffLeftEditorKey.set(true)));\n        this._register(editor.onDidBlurEditorWidget(() => isInDiffLeftEditorKey.set(false)));\n        this._register(editor.onDidContentSizeChange(e => {\n            const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n            const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());\n            this._onDidContentSizeChange.fire({\n                contentHeight: height,\n                contentWidth: width,\n                contentHeightChanged: e.contentHeightChanged,\n                contentWidthChanged: e.contentWidthChanged\n            });\n        }));\n        return editor;\n    }\n    _createRightHandSideEditor(options, codeEditorWidgetOptions) {\n        const editor = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options), codeEditorWidgetOptions);\n        this._register(editor.onDidScrollChange((e) => {\n            if (this._isHandlingScrollEvent) {\n                return;\n            }\n            if (!e.scrollTopChanged && !e.scrollLeftChanged && !e.scrollHeightChanged) {\n                return;\n            }\n            this._isHandlingScrollEvent = true;\n            this._originalEditor.setScrollPosition({\n                scrollLeft: e.scrollLeft,\n                scrollTop: e.scrollTop\n            });\n            this._isHandlingScrollEvent = false;\n            this._layoutOverviewViewport();\n        }));\n        this._register(editor.onDidChangeViewZones(() => {\n            this._onViewZonesChanged();\n        }));\n        this._register(editor.onDidChangeConfiguration((e) => {\n            if (!editor.getModel()) {\n                return;\n            }\n            if (e.hasChanged(44 /* fontInfo */)) {\n                this._updateDecorationsRunner.schedule();\n            }\n            if (e.hasChanged(132 /* wrappingInfo */)) {\n                this._updateDecorationsRunner.cancel();\n                this._updateDecorations();\n            }\n        }));\n        this._register(editor.onDidChangeHiddenAreas(() => {\n            this._updateDecorationsRunner.cancel();\n            this._updateDecorations();\n        }));\n        this._register(editor.onDidChangeModelContent(() => {\n            if (this._isVisible) {\n                this._beginUpdateDecorationsSoon();\n            }\n        }));\n        this._register(editor.onDidChangeModelOptions((e) => {\n            if (e.tabSize) {\n                this._updateDecorationsRunner.schedule();\n            }\n        }));\n        const isInDiffRightEditorKey = this._contextKeyService.createKey('isInDiffRightEditor', editor.hasWidgetFocus());\n        this._register(editor.onDidFocusEditorWidget(() => isInDiffRightEditorKey.set(true)));\n        this._register(editor.onDidBlurEditorWidget(() => isInDiffRightEditorKey.set(false)));\n        this._register(editor.onDidContentSizeChange(e => {\n            const width = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n            const height = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());\n            this._onDidContentSizeChange.fire({\n                contentHeight: height,\n                contentWidth: width,\n                contentHeightChanged: e.contentHeightChanged,\n                contentWidthChanged: e.contentWidthChanged\n            });\n        }));\n        return editor;\n    }\n    _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {\n        return instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);\n    }\n    dispose() {\n        this._codeEditorService.removeDiffEditor(this);\n        if (this._beginUpdateDecorationsTimeout !== -1) {\n            window.clearTimeout(this._beginUpdateDecorationsTimeout);\n            this._beginUpdateDecorationsTimeout = -1;\n        }\n        this._cleanViewZonesAndDecorations();\n        if (this._originalOverviewRuler) {\n            this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());\n            this._originalOverviewRuler.dispose();\n        }\n        if (this._modifiedOverviewRuler) {\n            this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());\n            this._modifiedOverviewRuler.dispose();\n        }\n        this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode);\n        if (this._options.renderOverviewRuler) {\n            this._containerDomElement.removeChild(this._overviewDomElement);\n        }\n        this._containerDomElement.removeChild(this._originalDomNode);\n        this._originalEditor.dispose();\n        this._containerDomElement.removeChild(this._modifiedDomNode);\n        this._modifiedEditor.dispose();\n        this._strategy.dispose();\n        this._containerDomElement.removeChild(this._reviewPane.domNode.domNode);\n        this._containerDomElement.removeChild(this._reviewPane.shadow.domNode);\n        this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode);\n        this._reviewPane.dispose();\n        this._domElement.removeChild(this._containerDomElement);\n        this._onDidDispose.fire();\n        super.dispose();\n    }\n    //------------ begin IDiffEditor methods\n    getId() {\n        return this.getEditorType() + ':' + this._id;\n    }\n    getEditorType() {\n        return editorCommon.EditorType.IDiffEditor;\n    }\n    getLineChanges() {\n        if (!this._diffComputationResult) {\n            return null;\n        }\n        return this._diffComputationResult.changes;\n    }\n    getOriginalEditor() {\n        return this._originalEditor;\n    }\n    getModifiedEditor() {\n        return this._modifiedEditor;\n    }\n    updateOptions(_newOptions) {\n        const newOptions = validateDiffEditorOptions(_newOptions, this._options);\n        const changed = changedDiffEditorOptions(this._options, newOptions);\n        this._options = newOptions;\n        const beginUpdateDecorations = (changed.ignoreTrimWhitespace || changed.renderIndicators);\n        const beginUpdateDecorationsSoon = (this._isVisible && (changed.maxComputationTime || changed.maxFileSize));\n        if (beginUpdateDecorations) {\n            this._beginUpdateDecorations();\n        }\n        else if (beginUpdateDecorationsSoon) {\n            this._beginUpdateDecorationsSoon();\n        }\n        this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(_newOptions));\n        this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(_newOptions));\n        // enableSplitViewResizing\n        this._strategy.setEnableSplitViewResizing(this._options.enableSplitViewResizing);\n        // renderSideBySide\n        if (changed.renderSideBySide) {\n            if (this._options.renderSideBySide) {\n                this._setStrategy(new DiffEditorWidgetSideBySide(this._createDataSource(), this._options.enableSplitViewResizing));\n            }\n            else {\n                this._setStrategy(new DiffEditorWidgetInline(this._createDataSource(), this._options.enableSplitViewResizing));\n            }\n            // Update class name\n            this._containerDomElement.className = DiffEditorWidget._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);\n        }\n        // renderOverviewRuler\n        if (changed.renderOverviewRuler) {\n            if (this._options.renderOverviewRuler) {\n                this._containerDomElement.appendChild(this._overviewDomElement);\n            }\n            else {\n                this._containerDomElement.removeChild(this._overviewDomElement);\n            }\n        }\n    }\n    getModel() {\n        return {\n            original: this._originalEditor.getModel(),\n            modified: this._modifiedEditor.getModel()\n        };\n    }\n    setModel(model) {\n        // Guard us against partial null model\n        if (model && (!model.original || !model.modified)) {\n            throw new Error(!model.original ? 'DiffEditorWidget.setModel: Original model is null' : 'DiffEditorWidget.setModel: Modified model is null');\n        }\n        // Remove all view zones & decorations\n        this._cleanViewZonesAndDecorations();\n        // Update code editor models\n        this._originalEditor.setModel(model ? model.original : null);\n        this._modifiedEditor.setModel(model ? model.modified : null);\n        this._updateDecorationsRunner.cancel();\n        // this.originalEditor.onDidChangeModelOptions\n        if (model) {\n            this._originalEditor.setScrollTop(0);\n            this._modifiedEditor.setScrollTop(0);\n        }\n        // Disable any diff computations that will come in\n        this._diffComputationResult = null;\n        this._diffComputationToken++;\n        this._setState(0 /* Idle */);\n        if (model) {\n            this._recreateOverviewRulers();\n            // Begin comparing\n            this._beginUpdateDecorations();\n        }\n        this._layoutOverviewViewport();\n    }\n    getContainerDomNode() {\n        return this._domElement;\n    }\n    getVisibleColumnFromPosition(position) {\n        return this._modifiedEditor.getVisibleColumnFromPosition(position);\n    }\n    getPosition() {\n        return this._modifiedEditor.getPosition();\n    }\n    setPosition(position, source = 'api') {\n        this._modifiedEditor.setPosition(position, source);\n    }\n    revealLine(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLine(lineNumber, scrollType);\n    }\n    revealLineInCenter(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLineInCenter(lineNumber, scrollType);\n    }\n    revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);\n    }\n    revealLineNearTop(lineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLineNearTop(lineNumber, scrollType);\n    }\n    revealPosition(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPosition(position, scrollType);\n    }\n    revealPositionInCenter(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPositionInCenter(position, scrollType);\n    }\n    revealPositionInCenterIfOutsideViewport(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPositionInCenterIfOutsideViewport(position, scrollType);\n    }\n    revealPositionNearTop(position, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealPositionNearTop(position, scrollType);\n    }\n    getSelection() {\n        return this._modifiedEditor.getSelection();\n    }\n    getSelections() {\n        return this._modifiedEditor.getSelections();\n    }\n    setSelection(something, source = 'api') {\n        this._modifiedEditor.setSelection(something, source);\n    }\n    setSelections(ranges, source = 'api') {\n        this._modifiedEditor.setSelections(ranges, source);\n    }\n    revealLines(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLines(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);\n    }\n    revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealLinesNearTop(startLineNumber, endLineNumber, scrollType);\n    }\n    revealRange(range, scrollType = 0 /* Smooth */, revealVerticalInCenter = false, revealHorizontal = true) {\n        this._modifiedEditor.revealRange(range, scrollType, revealVerticalInCenter, revealHorizontal);\n    }\n    revealRangeInCenter(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeInCenter(range, scrollType);\n    }\n    revealRangeInCenterIfOutsideViewport(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeInCenterIfOutsideViewport(range, scrollType);\n    }\n    revealRangeNearTop(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeNearTop(range, scrollType);\n    }\n    revealRangeNearTopIfOutsideViewport(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeNearTopIfOutsideViewport(range, scrollType);\n    }\n    revealRangeAtTop(range, scrollType = 0 /* Smooth */) {\n        this._modifiedEditor.revealRangeAtTop(range, scrollType);\n    }\n    getSupportedActions() {\n        return this._modifiedEditor.getSupportedActions();\n    }\n    saveViewState() {\n        const originalViewState = this._originalEditor.saveViewState();\n        const modifiedViewState = this._modifiedEditor.saveViewState();\n        return {\n            original: originalViewState,\n            modified: modifiedViewState\n        };\n    }\n    restoreViewState(s) {\n        if (s && s.original && s.modified) {\n            const diffEditorState = s;\n            this._originalEditor.restoreViewState(diffEditorState.original);\n            this._modifiedEditor.restoreViewState(diffEditorState.modified);\n        }\n    }\n    layout(dimension) {\n        this._elementSizeObserver.observe(dimension);\n    }\n    focus() {\n        this._modifiedEditor.focus();\n    }\n    hasTextFocus() {\n        return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();\n    }\n    trigger(source, handlerId, payload) {\n        this._modifiedEditor.trigger(source, handlerId, payload);\n    }\n    changeDecorations(callback) {\n        return this._modifiedEditor.changeDecorations(callback);\n    }\n    //------------ end IDiffEditor methods\n    //------------ begin layouting methods\n    _onDidContainerSizeChanged() {\n        this._doLayout();\n    }\n    _getReviewHeight() {\n        return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;\n    }\n    _layoutOverviewRulers() {\n        if (!this._options.renderOverviewRuler) {\n            return;\n        }\n        if (!this._originalOverviewRuler || !this._modifiedOverviewRuler) {\n            return;\n        }\n        const height = this._elementSizeObserver.getHeight();\n        const reviewHeight = this._getReviewHeight();\n        const freeSpace = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget.ONE_OVERVIEW_WIDTH;\n        const layoutInfo = this._modifiedEditor.getLayoutInfo();\n        if (layoutInfo) {\n            this._originalOverviewRuler.setLayout({\n                top: 0,\n                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                right: freeSpace + DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                height: (height - reviewHeight)\n            });\n            this._modifiedOverviewRuler.setLayout({\n                top: 0,\n                right: 0,\n                width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,\n                height: (height - reviewHeight)\n            });\n        }\n    }\n    //------------ end layouting methods\n    _onViewZonesChanged() {\n        if (this._currentlyChangingViewZones) {\n            return;\n        }\n        this._updateDecorationsRunner.schedule();\n    }\n    _beginUpdateDecorationsSoon() {\n        // Clear previous timeout if necessary\n        if (this._beginUpdateDecorationsTimeout !== -1) {\n            window.clearTimeout(this._beginUpdateDecorationsTimeout);\n            this._beginUpdateDecorationsTimeout = -1;\n        }\n        this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY);\n    }\n    static _equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return (a.toString() === b.toString());\n    }\n    _beginUpdateDecorations() {\n        this._beginUpdateDecorationsTimeout = -1;\n        const currentOriginalModel = this._originalEditor.getModel();\n        const currentModifiedModel = this._modifiedEditor.getModel();\n        if (!currentOriginalModel || !currentModifiedModel) {\n            return;\n        }\n        // Prevent old diff requests to come if a new request has been initiated\n        // The best method would be to call cancel on the Promise, but this is not\n        // yet supported, so using tokens for now.\n        this._diffComputationToken++;\n        const currentToken = this._diffComputationToken;\n        const diffLimit = this._options.maxFileSize * 1024 * 1024; // MB\n        const canSyncModelForDiff = (model) => {\n            const bufferTextLength = model.getValueLength();\n            return (diffLimit === 0 || bufferTextLength <= diffLimit);\n        };\n        if (!canSyncModelForDiff(currentOriginalModel) || !canSyncModelForDiff(currentModifiedModel)) {\n            if (!DiffEditorWidget._equals(currentOriginalModel.uri, this._lastOriginalWarning)\n                || !DiffEditorWidget._equals(currentModifiedModel.uri, this._lastModifiedWarning)) {\n                this._lastOriginalWarning = currentOriginalModel.uri;\n                this._lastModifiedWarning = currentModifiedModel.uri;\n                this._notificationService.warn(nls.localize(\"diff.tooLarge\", \"Cannot compare files because one file is too large.\"));\n            }\n            return;\n        }\n        this._setState(1 /* ComputingDiff */);\n        this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._options.ignoreTrimWhitespace, this._options.maxComputationTime).then((result) => {\n            if (currentToken === this._diffComputationToken\n                && currentOriginalModel === this._originalEditor.getModel()\n                && currentModifiedModel === this._modifiedEditor.getModel()) {\n                this._setState(2 /* DiffComputed */);\n                this._diffComputationResult = result;\n                this._updateDecorationsRunner.schedule();\n                this._onDidUpdateDiff.fire();\n            }\n        }, (error) => {\n            if (currentToken === this._diffComputationToken\n                && currentOriginalModel === this._originalEditor.getModel()\n                && currentModifiedModel === this._modifiedEditor.getModel()) {\n                this._setState(2 /* DiffComputed */);\n                this._diffComputationResult = null;\n                this._updateDecorationsRunner.schedule();\n            }\n        });\n    }\n    _cleanViewZonesAndDecorations() {\n        this._originalEditorState.clean(this._originalEditor);\n        this._modifiedEditorState.clean(this._modifiedEditor);\n    }\n    _updateDecorations() {\n        if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel()) {\n            return;\n        }\n        const lineChanges = (this._diffComputationResult ? this._diffComputationResult.changes : []);\n        const foreignOriginal = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces());\n        const foreignModified = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces());\n        const diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._options.ignoreTrimWhitespace, this._options.renderIndicators, foreignOriginal, foreignModified);\n        try {\n            this._currentlyChangingViewZones = true;\n            this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, diffDecorations.original, false);\n            this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified, true);\n        }\n        finally {\n            this._currentlyChangingViewZones = false;\n        }\n    }\n    _adjustOptionsForSubEditor(options) {\n        const clonedOptions = Object.assign({}, options);\n        clonedOptions.inDiffEditor = true;\n        clonedOptions.automaticLayout = false;\n        // Clone scrollbar options before changing them\n        clonedOptions.scrollbar = Object.assign({}, (clonedOptions.scrollbar || {}));\n        clonedOptions.scrollbar.vertical = 'visible';\n        clonedOptions.folding = false;\n        clonedOptions.codeLens = this._options.diffCodeLens;\n        clonedOptions.fixedOverflowWidgets = true;\n        // clonedOptions.lineDecorationsWidth = '2ch';\n        // Clone minimap options before changing them\n        clonedOptions.minimap = Object.assign({}, (clonedOptions.minimap || {}));\n        clonedOptions.minimap.enabled = false;\n        return clonedOptions;\n    }\n    _adjustOptionsForLeftHandSide(options) {\n        const result = this._adjustOptionsForSubEditor(options);\n        if (!this._options.renderSideBySide) {\n            // never wrap hidden editor\n            result.wordWrapOverride1 = 'off';\n            result.wordWrapOverride2 = 'off';\n        }\n        else {\n            result.wordWrapOverride1 = this._options.diffWordWrap;\n        }\n        if (options.originalAriaLabel) {\n            result.ariaLabel = options.originalAriaLabel;\n        }\n        result.readOnly = !this._options.originalEditable;\n        result.extraEditorClassName = 'original-in-monaco-diff-editor';\n        return Object.assign(Object.assign({}, result), { dimension: {\n                height: 0,\n                width: 0\n            } });\n    }\n    _adjustOptionsForRightHandSide(options) {\n        const result = this._adjustOptionsForSubEditor(options);\n        if (options.modifiedAriaLabel) {\n            result.ariaLabel = options.modifiedAriaLabel;\n        }\n        result.wordWrapOverride1 = this._options.diffWordWrap;\n        result.revealHorizontalRightPadding = EditorOptions.revealHorizontalRightPadding.defaultValue + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;\n        result.scrollbar.verticalHasArrows = false;\n        result.extraEditorClassName = 'modified-in-monaco-diff-editor';\n        return Object.assign(Object.assign({}, result), { dimension: {\n                height: 0,\n                width: 0\n            } });\n    }\n    doLayout() {\n        this._elementSizeObserver.observe();\n        this._doLayout();\n    }\n    _doLayout() {\n        const width = this._elementSizeObserver.getWidth();\n        const height = this._elementSizeObserver.getHeight();\n        const reviewHeight = this._getReviewHeight();\n        const splitPoint = this._strategy.layout();\n        this._originalDomNode.style.width = splitPoint + 'px';\n        this._originalDomNode.style.left = '0px';\n        this._modifiedDomNode.style.width = (width - splitPoint) + 'px';\n        this._modifiedDomNode.style.left = splitPoint + 'px';\n        this._overviewDomElement.style.top = '0px';\n        this._overviewDomElement.style.height = (height - reviewHeight) + 'px';\n        this._overviewDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';\n        this._overviewDomElement.style.left = (width - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH) + 'px';\n        this._overviewViewportDomElement.setWidth(DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH);\n        this._overviewViewportDomElement.setHeight(30);\n        this._originalEditor.layout({ width: splitPoint, height: (height - reviewHeight) });\n        this._modifiedEditor.layout({ width: width - splitPoint - (this._options.renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: (height - reviewHeight) });\n        if (this._originalOverviewRuler || this._modifiedOverviewRuler) {\n            this._layoutOverviewRulers();\n        }\n        this._reviewPane.layout(height - reviewHeight, width, reviewHeight);\n        this._layoutOverviewViewport();\n    }\n    _layoutOverviewViewport() {\n        const layout = this._computeOverviewViewport();\n        if (!layout) {\n            this._overviewViewportDomElement.setTop(0);\n            this._overviewViewportDomElement.setHeight(0);\n        }\n        else {\n            this._overviewViewportDomElement.setTop(layout.top);\n            this._overviewViewportDomElement.setHeight(layout.height);\n        }\n    }\n    _computeOverviewViewport() {\n        const layoutInfo = this._modifiedEditor.getLayoutInfo();\n        if (!layoutInfo) {\n            return null;\n        }\n        const scrollTop = this._modifiedEditor.getScrollTop();\n        const scrollHeight = this._modifiedEditor.getScrollHeight();\n        const computedAvailableSize = Math.max(0, layoutInfo.height);\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);\n        const computedRatio = scrollHeight > 0 ? (computedRepresentableSize / scrollHeight) : 0;\n        const computedSliderSize = Math.max(0, Math.floor(layoutInfo.height * computedRatio));\n        const computedSliderPosition = Math.floor(scrollTop * computedRatio);\n        return {\n            height: computedSliderSize,\n            top: computedSliderPosition\n        };\n    }\n    _createDataSource() {\n        return {\n            getWidth: () => {\n                return this._elementSizeObserver.getWidth();\n            },\n            getHeight: () => {\n                return (this._elementSizeObserver.getHeight() - this._getReviewHeight());\n            },\n            getOptions: () => {\n                return {\n                    renderOverviewRuler: this._options.renderOverviewRuler\n                };\n            },\n            getContainerDomNode: () => {\n                return this._containerDomElement;\n            },\n            relayoutEditors: () => {\n                this._doLayout();\n            },\n            getOriginalEditor: () => {\n                return this._originalEditor;\n            },\n            getModifiedEditor: () => {\n                return this._modifiedEditor;\n            }\n        };\n    }\n    _setStrategy(newStrategy) {\n        if (this._strategy) {\n            this._strategy.dispose();\n        }\n        this._strategy = newStrategy;\n        newStrategy.applyColors(this._themeService.getColorTheme());\n        if (this._diffComputationResult) {\n            this._updateDecorations();\n        }\n        // Just do a layout, the strategy might need it\n        this._doLayout();\n    }\n    _getLineChangeAtOrBeforeLineNumber(lineNumber, startLineNumberExtractor) {\n        const lineChanges = (this._diffComputationResult ? this._diffComputationResult.changes : []);\n        if (lineChanges.length === 0 || lineNumber < startLineNumberExtractor(lineChanges[0])) {\n            // There are no changes or `lineNumber` is before the first change\n            return null;\n        }\n        let min = 0;\n        let max = lineChanges.length - 1;\n        while (min < max) {\n            const mid = Math.floor((min + max) / 2);\n            const midStart = startLineNumberExtractor(lineChanges[mid]);\n            const midEnd = (mid + 1 <= max ? startLineNumberExtractor(lineChanges[mid + 1]) : 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n            if (lineNumber < midStart) {\n                max = mid - 1;\n            }\n            else if (lineNumber >= midEnd) {\n                min = mid + 1;\n            }\n            else {\n                // HIT!\n                min = mid;\n                max = mid;\n            }\n        }\n        return lineChanges[min];\n    }\n    _getEquivalentLineForOriginalLineNumber(lineNumber) {\n        const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange) => lineChange.originalStartLineNumber);\n        if (!lineChange) {\n            return lineNumber;\n        }\n        const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n        const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n        const lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);\n        const lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);\n        const delta = lineNumber - originalEquivalentLineNumber;\n        if (delta <= lineChangeOriginalLength) {\n            return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);\n        }\n        return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;\n    }\n    _getEquivalentLineForModifiedLineNumber(lineNumber) {\n        const lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, (lineChange) => lineChange.modifiedStartLineNumber);\n        if (!lineChange) {\n            return lineNumber;\n        }\n        const originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n        const modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n        const lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);\n        const lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);\n        const delta = lineNumber - modifiedEquivalentLineNumber;\n        if (delta <= lineChangeModifiedLength) {\n            return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);\n        }\n        return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;\n    }\n    getDiffLineInformationForOriginal(lineNumber) {\n        if (!this._diffComputationResult) {\n            // Cannot answer that which I don't know\n            return null;\n        }\n        return {\n            equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)\n        };\n    }\n    getDiffLineInformationForModified(lineNumber) {\n        if (!this._diffComputationResult) {\n            // Cannot answer that which I don't know\n            return null;\n        }\n        return {\n            equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)\n        };\n    }\n};\nDiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;\nDiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;\nDiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200; // ms\nDiffEditorWidget = __decorate([\n    __param(3, IClipboardService),\n    __param(4, IEditorWorkerService),\n    __param(5, IContextKeyService),\n    __param(6, IInstantiationService),\n    __param(7, ICodeEditorService),\n    __param(8, IThemeService),\n    __param(9, INotificationService),\n    __param(10, IContextMenuService),\n    __param(11, IEditorProgressService)\n], DiffEditorWidget);\nexport { DiffEditorWidget };\nclass DiffEditorWidgetStyle extends Disposable {\n    constructor(dataSource) {\n        super();\n        this._dataSource = dataSource;\n        this._insertColor = null;\n        this._removeColor = null;\n    }\n    applyColors(theme) {\n        const newInsertColor = theme.getColor(diffOverviewRulerInserted) || (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);\n        const newRemoveColor = theme.getColor(diffOverviewRulerRemoved) || (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);\n        const hasChanges = !newInsertColor.equals(this._insertColor) || !newRemoveColor.equals(this._removeColor);\n        this._insertColor = newInsertColor;\n        this._removeColor = newRemoveColor;\n        return hasChanges;\n    }\n    getEditorsDiffDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalWhitespaces, modifiedWhitespaces) {\n        // Get view zones\n        modifiedWhitespaces = modifiedWhitespaces.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        originalWhitespaces = originalWhitespaces.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        const zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, renderIndicators);\n        // Get decorations & overview ruler zones\n        const originalDecorations = this._getOriginalEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators);\n        const modifiedDecorations = this._getModifiedEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators);\n        return {\n            original: {\n                decorations: originalDecorations.decorations,\n                overviewZones: originalDecorations.overviewZones,\n                zones: zones.original\n            },\n            modified: {\n                decorations: modifiedDecorations.decorations,\n                overviewZones: modifiedDecorations.overviewZones,\n                zones: zones.modified\n            }\n        };\n    }\n}\nclass ForeignViewZonesIterator {\n    constructor(source) {\n        this._source = source;\n        this._index = -1;\n        this.current = null;\n        this.advance();\n    }\n    advance() {\n        this._index++;\n        if (this._index < this._source.length) {\n            this.current = this._source[this._index];\n        }\n        else {\n            this.current = null;\n        }\n    }\n}\nclass ViewZonesComputer {\n    constructor(_lineChanges, _originalForeignVZ, _modifiedForeignVZ, _originalEditor, _modifiedEditor) {\n        this._lineChanges = _lineChanges;\n        this._originalForeignVZ = _originalForeignVZ;\n        this._modifiedForeignVZ = _modifiedForeignVZ;\n        this._originalEditor = _originalEditor;\n        this._modifiedEditor = _modifiedEditor;\n    }\n    static _getViewLineCount(editor, startLineNumber, endLineNumber) {\n        const model = editor.getModel();\n        const viewModel = editor._getViewModel();\n        if (model && viewModel) {\n            const viewRange = getViewRange(model, viewModel, startLineNumber, endLineNumber);\n            return (viewRange.endLineNumber - viewRange.startLineNumber + 1);\n        }\n        return (endLineNumber - startLineNumber + 1);\n    }\n    getViewZones() {\n        const originalLineHeight = this._originalEditor.getOption(59 /* lineHeight */);\n        const modifiedLineHeight = this._modifiedEditor.getOption(59 /* lineHeight */);\n        const originalHasWrapping = (this._originalEditor.getOption(132 /* wrappingInfo */).wrappingColumn !== -1);\n        const modifiedHasWrapping = (this._modifiedEditor.getOption(132 /* wrappingInfo */).wrappingColumn !== -1);\n        const hasWrapping = (originalHasWrapping || modifiedHasWrapping);\n        const originalModel = this._originalEditor.getModel();\n        const originalCoordinatesConverter = this._originalEditor._getViewModel().coordinatesConverter;\n        const modifiedCoordinatesConverter = this._modifiedEditor._getViewModel().coordinatesConverter;\n        const result = {\n            original: [],\n            modified: []\n        };\n        let lineChangeModifiedLength = 0;\n        let lineChangeOriginalLength = 0;\n        let originalEquivalentLineNumber = 0;\n        let modifiedEquivalentLineNumber = 0;\n        let originalEndEquivalentLineNumber = 0;\n        let modifiedEndEquivalentLineNumber = 0;\n        const sortMyViewZones = (a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        };\n        const addAndCombineIfPossible = (destination, item) => {\n            if (item.domNode === null && destination.length > 0) {\n                const lastItem = destination[destination.length - 1];\n                if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {\n                    lastItem.heightInLines += item.heightInLines;\n                    return;\n                }\n            }\n            destination.push(item);\n        };\n        const modifiedForeignVZ = new ForeignViewZonesIterator(this._modifiedForeignVZ);\n        const originalForeignVZ = new ForeignViewZonesIterator(this._originalForeignVZ);\n        let lastOriginalLineNumber = 1;\n        let lastModifiedLineNumber = 1;\n        // In order to include foreign view zones after the last line change, the for loop will iterate once more after the end of the `lineChanges` array\n        for (let i = 0, length = this._lineChanges.length; i <= length; i++) {\n            const lineChange = (i < length ? this._lineChanges[i] : null);\n            if (lineChange !== null) {\n                originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);\n                modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);\n                lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._originalEditor, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber) : 0);\n                lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? ViewZonesComputer._getViewLineCount(this._modifiedEditor, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber) : 0);\n                originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n            }\n            else {\n                // Increase to very large value to get the producing tests of foreign view zones running\n                originalEquivalentLineNumber += 10000000 + lineChangeOriginalLength;\n                modifiedEquivalentLineNumber += 10000000 + lineChangeModifiedLength;\n                originalEndEquivalentLineNumber = originalEquivalentLineNumber;\n                modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;\n            }\n            // Each step produces view zones, and after producing them, we try to cancel them out, to avoid empty-empty view zone cases\n            let stepOriginal = [];\n            let stepModified = [];\n            // ---------------------------- PRODUCE VIEW ZONES\n            // [PRODUCE] View zones due to line mapping differences (equal lines but wrapped differently)\n            if (hasWrapping) {\n                let count;\n                if (lineChange) {\n                    if (lineChange.originalEndLineNumber > 0) {\n                        count = lineChange.originalStartLineNumber - lastOriginalLineNumber;\n                    }\n                    else {\n                        count = lineChange.modifiedStartLineNumber - lastModifiedLineNumber;\n                    }\n                }\n                else {\n                    // `lastOriginalLineNumber` has not been looked at yet\n                    count = originalModel.getLineCount() - lastOriginalLineNumber + 1;\n                }\n                for (let i = 0; i < count; i++) {\n                    const originalLineNumber = lastOriginalLineNumber + i;\n                    const modifiedLineNumber = lastModifiedLineNumber + i;\n                    const originalViewLineCount = originalCoordinatesConverter.getModelLineViewLineCount(originalLineNumber);\n                    const modifiedViewLineCount = modifiedCoordinatesConverter.getModelLineViewLineCount(modifiedLineNumber);\n                    if (originalViewLineCount < modifiedViewLineCount) {\n                        stepOriginal.push({\n                            afterLineNumber: originalLineNumber,\n                            heightInLines: modifiedViewLineCount - originalViewLineCount,\n                            domNode: null,\n                            marginDomNode: null\n                        });\n                    }\n                    else if (originalViewLineCount > modifiedViewLineCount) {\n                        stepModified.push({\n                            afterLineNumber: modifiedLineNumber,\n                            heightInLines: originalViewLineCount - modifiedViewLineCount,\n                            domNode: null,\n                            marginDomNode: null\n                        });\n                    }\n                }\n                if (lineChange) {\n                    lastOriginalLineNumber = (lineChange.originalEndLineNumber > 0 ? lineChange.originalEndLineNumber : lineChange.originalStartLineNumber) + 1;\n                    lastModifiedLineNumber = (lineChange.modifiedEndLineNumber > 0 ? lineChange.modifiedEndLineNumber : lineChange.modifiedStartLineNumber) + 1;\n                }\n            }\n            // [PRODUCE] View zone(s) in original-side due to foreign view zone(s) in modified-side\n            while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {\n                let viewZoneLineNumber;\n                if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {\n                    viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;\n                }\n                else {\n                    viewZoneLineNumber = originalEndEquivalentLineNumber;\n                }\n                let marginDomNode = null;\n                if (lineChange && lineChange.modifiedStartLineNumber <= modifiedForeignVZ.current.afterLineNumber && modifiedForeignVZ.current.afterLineNumber <= lineChange.modifiedEndLineNumber) {\n                    marginDomNode = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion();\n                }\n                stepOriginal.push({\n                    afterLineNumber: viewZoneLineNumber,\n                    heightInLines: modifiedForeignVZ.current.height / modifiedLineHeight,\n                    domNode: null,\n                    marginDomNode: marginDomNode\n                });\n                modifiedForeignVZ.advance();\n            }\n            // [PRODUCE] View zone(s) in modified-side due to foreign view zone(s) in original-side\n            while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {\n                let viewZoneLineNumber;\n                if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {\n                    viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;\n                }\n                else {\n                    viewZoneLineNumber = modifiedEndEquivalentLineNumber;\n                }\n                stepModified.push({\n                    afterLineNumber: viewZoneLineNumber,\n                    heightInLines: originalForeignVZ.current.height / originalLineHeight,\n                    domNode: null\n                });\n                originalForeignVZ.advance();\n            }\n            if (lineChange !== null && isChangeOrInsert(lineChange)) {\n                const r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);\n                if (r) {\n                    stepOriginal.push(r);\n                }\n            }\n            if (lineChange !== null && isChangeOrDelete(lineChange)) {\n                const r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);\n                if (r) {\n                    stepModified.push(r);\n                }\n            }\n            // ---------------------------- END PRODUCE VIEW ZONES\n            // ---------------------------- EMIT MINIMAL VIEW ZONES\n            // [CANCEL & EMIT] Try to cancel view zones out\n            let stepOriginalIndex = 0;\n            let stepModifiedIndex = 0;\n            stepOriginal = stepOriginal.sort(sortMyViewZones);\n            stepModified = stepModified.sort(sortMyViewZones);\n            while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {\n                const original = stepOriginal[stepOriginalIndex];\n                const modified = stepModified[stepModifiedIndex];\n                const originalDelta = original.afterLineNumber - originalEquivalentLineNumber;\n                const modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;\n                if (originalDelta < modifiedDelta) {\n                    addAndCombineIfPossible(result.original, original);\n                    stepOriginalIndex++;\n                }\n                else if (modifiedDelta < originalDelta) {\n                    addAndCombineIfPossible(result.modified, modified);\n                    stepModifiedIndex++;\n                }\n                else if (original.shouldNotShrink) {\n                    addAndCombineIfPossible(result.original, original);\n                    stepOriginalIndex++;\n                }\n                else if (modified.shouldNotShrink) {\n                    addAndCombineIfPossible(result.modified, modified);\n                    stepModifiedIndex++;\n                }\n                else {\n                    if (original.heightInLines >= modified.heightInLines) {\n                        // modified view zone gets removed\n                        original.heightInLines -= modified.heightInLines;\n                        stepModifiedIndex++;\n                    }\n                    else {\n                        // original view zone gets removed\n                        modified.heightInLines -= original.heightInLines;\n                        stepOriginalIndex++;\n                    }\n                }\n            }\n            // [EMIT] Remaining original view zones\n            while (stepOriginalIndex < stepOriginal.length) {\n                addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);\n                stepOriginalIndex++;\n            }\n            // [EMIT] Remaining modified view zones\n            while (stepModifiedIndex < stepModified.length) {\n                addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);\n                stepModifiedIndex++;\n            }\n            // ---------------------------- END EMIT MINIMAL VIEW ZONES\n        }\n        return {\n            original: ViewZonesComputer._ensureDomNodes(result.original),\n            modified: ViewZonesComputer._ensureDomNodes(result.modified),\n        };\n    }\n    static _ensureDomNodes(zones) {\n        return zones.map((z) => {\n            if (!z.domNode) {\n                z.domNode = createFakeLinesDiv();\n            }\n            return z;\n        });\n    }\n}\nfunction createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, options) {\n    return {\n        range: new Range(startLineNumber, startColumn, endLineNumber, endColumn),\n        options: options\n    };\n}\nconst DECORATIONS = {\n    charDelete: ModelDecorationOptions.register({\n        description: 'diff-editor-char-delete',\n        className: 'char-delete'\n    }),\n    charDeleteWholeLine: ModelDecorationOptions.register({\n        description: 'diff-editor-char-delete-whole-line',\n        className: 'char-delete',\n        isWholeLine: true\n    }),\n    charInsert: ModelDecorationOptions.register({\n        description: 'diff-editor-char-insert',\n        className: 'char-insert'\n    }),\n    charInsertWholeLine: ModelDecorationOptions.register({\n        description: 'diff-editor-char-insert-whole-line',\n        className: 'char-insert',\n        isWholeLine: true\n    }),\n    lineInsert: ModelDecorationOptions.register({\n        description: 'diff-editor-line-insert',\n        className: 'line-insert',\n        marginClassName: 'gutter-insert',\n        isWholeLine: true\n    }),\n    lineInsertWithSign: ModelDecorationOptions.register({\n        description: 'diff-editor-line-insert-with-sign',\n        className: 'line-insert',\n        linesDecorationsClassName: 'insert-sign ' + ThemeIcon.asClassName(diffInsertIcon),\n        marginClassName: 'gutter-insert',\n        isWholeLine: true\n    }),\n    lineDelete: ModelDecorationOptions.register({\n        description: 'diff-editor-line-delete',\n        className: 'line-delete',\n        marginClassName: 'gutter-delete',\n        isWholeLine: true\n    }),\n    lineDeleteWithSign: ModelDecorationOptions.register({\n        description: 'diff-editor-line-delete-with-sign',\n        className: 'line-delete',\n        linesDecorationsClassName: 'delete-sign ' + ThemeIcon.asClassName(diffRemoveIcon),\n        marginClassName: 'gutter-delete',\n        isWholeLine: true\n    }),\n    lineDeleteMargin: ModelDecorationOptions.register({\n        description: 'diff-editor-line-delete-margin',\n        marginClassName: 'gutter-delete',\n    })\n};\nclass DiffEditorWidgetSideBySide extends DiffEditorWidgetStyle {\n    constructor(dataSource, enableSplitViewResizing) {\n        super(dataSource);\n        this._disableSash = (enableSplitViewResizing === false);\n        this._sashRatio = null;\n        this._sashPosition = null;\n        this._startSashPosition = null;\n        this._sash = this._register(new Sash(this._dataSource.getContainerDomNode(), this, { orientation: 0 /* VERTICAL */ }));\n        if (this._disableSash) {\n            this._sash.state = 0 /* Disabled */;\n        }\n        this._sash.onDidStart(() => this._onSashDragStart());\n        this._sash.onDidChange((e) => this._onSashDrag(e));\n        this._sash.onDidEnd(() => this._onSashDragEnd());\n        this._sash.onDidReset(() => this._onSashReset());\n    }\n    setEnableSplitViewResizing(enableSplitViewResizing) {\n        const newDisableSash = (enableSplitViewResizing === false);\n        if (this._disableSash !== newDisableSash) {\n            this._disableSash = newDisableSash;\n            this._sash.state = this._disableSash ? 0 /* Disabled */ : 3 /* Enabled */;\n        }\n    }\n    layout(sashRatio = this._sashRatio) {\n        const w = this._dataSource.getWidth();\n        const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);\n        let sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);\n        const midPoint = Math.floor(0.5 * contentWidth);\n        sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;\n        if (contentWidth > DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {\n            if (sashPosition < DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {\n                sashPosition = DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;\n            }\n            if (sashPosition > contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {\n                sashPosition = contentWidth - DiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;\n            }\n        }\n        else {\n            sashPosition = midPoint;\n        }\n        if (this._sashPosition !== sashPosition) {\n            this._sashPosition = sashPosition;\n        }\n        this._sash.layout();\n        return this._sashPosition;\n    }\n    _onSashDragStart() {\n        this._startSashPosition = this._sashPosition;\n    }\n    _onSashDrag(e) {\n        const w = this._dataSource.getWidth();\n        const contentWidth = w - (this._dataSource.getOptions().renderOverviewRuler ? DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);\n        const sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);\n        this._sashRatio = sashPosition / contentWidth;\n        this._dataSource.relayoutEditors();\n    }\n    _onSashDragEnd() {\n        this._sash.layout();\n    }\n    _onSashReset() {\n        this._sashRatio = 0.5;\n        this._dataSource.relayoutEditors();\n        this._sash.layout();\n    }\n    getVerticalSashTop(sash) {\n        return 0;\n    }\n    getVerticalSashLeft(sash) {\n        return this._sashPosition;\n    }\n    getVerticalSashHeight(sash) {\n        return this._dataSource.getHeight();\n    }\n    _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n        return c.getViewZones();\n    }\n    _getOriginalEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const overviewZoneColor = String(this._removeColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const originalModel = originalEditor.getModel();\n        const originalViewModel = originalEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            if (isChangeOrDelete(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineDeleteWithSign : DECORATIONS.lineDelete)\n                });\n                if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {\n                    result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charDeleteWholeLine));\n                }\n                const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, /*use endLineNumber*/ 0, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isChangeOrDelete(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.originalStartLineNumber) {\n                                        startColumn = charChange.originalStartColumn;\n                                    }\n                                    else {\n                                        startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.originalEndLineNumber) {\n                                        endColumn = charChange.originalEndColumn;\n                                    }\n                                    else {\n                                        endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charDelete));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, DECORATIONS.charDelete));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    _getModifiedEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const overviewZoneColor = String(this._insertColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const modifiedModel = modifiedEditor.getModel();\n        const modifiedViewModel = modifiedEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            if (isChangeOrInsert(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)\n                });\n                if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {\n                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charInsertWholeLine));\n                }\n                const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, /*use endLineNumber*/ 0, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isChangeOrInsert(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.modifiedStartLineNumber) {\n                                        startColumn = charChange.modifiedStartColumn;\n                                    }\n                                    else {\n                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.modifiedEndLineNumber) {\n                                        endColumn = charChange.modifiedEndColumn;\n                                    }\n                                    else {\n                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nDiffEditorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;\nclass SideBySideViewZonesComputer extends ViewZonesComputer {\n    constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {\n        super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n    }\n    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {\n        return null;\n    }\n    _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        if (lineChangeModifiedLength > lineChangeOriginalLength) {\n            return {\n                afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),\n                heightInLines: (lineChangeModifiedLength - lineChangeOriginalLength),\n                domNode: null\n            };\n        }\n        return null;\n    }\n    _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        if (lineChangeOriginalLength > lineChangeModifiedLength) {\n            return {\n                afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),\n                heightInLines: (lineChangeOriginalLength - lineChangeModifiedLength),\n                domNode: null\n            };\n        }\n        return null;\n    }\n}\nclass DiffEditorWidgetInline extends DiffEditorWidgetStyle {\n    constructor(dataSource, enableSplitViewResizing) {\n        super(dataSource);\n        this._decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;\n        this._register(dataSource.getOriginalEditor().onDidLayoutChange((layoutInfo) => {\n            if (this._decorationsLeft !== layoutInfo.decorationsLeft) {\n                this._decorationsLeft = layoutInfo.decorationsLeft;\n                dataSource.relayoutEditors();\n            }\n        }));\n    }\n    setEnableSplitViewResizing(enableSplitViewResizing) {\n        // Nothing to do..\n    }\n    _getViewZones(lineChanges, originalForeignVZ, modifiedForeignVZ, renderIndicators) {\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);\n        return computer.getViewZones();\n    }\n    _getOriginalEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const overviewZoneColor = String(this._removeColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const originalEditor = this._dataSource.getOriginalEditor();\n        const originalModel = originalEditor.getModel();\n        const originalViewModel = originalEditor._getViewModel();\n        let zoneIndex = 0;\n        for (const lineChange of lineChanges) {\n            // Add overview zones in the overview ruler\n            if (isChangeOrDelete(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: DECORATIONS.lineDeleteMargin\n                });\n                while (zoneIndex < zones.modified.length) {\n                    const zone = zones.modified[zoneIndex];\n                    if (zone.diff && zone.diff.originalStartLineNumber >= lineChange.originalStartLineNumber) {\n                        break;\n                    }\n                    zoneIndex++;\n                }\n                let zoneHeightInLines = 0;\n                if (zoneIndex < zones.modified.length) {\n                    const zone = zones.modified[zoneIndex];\n                    if (zone.diff\n                        && zone.diff.originalStartLineNumber === lineChange.originalStartLineNumber\n                        && zone.diff.originalEndLineNumber === lineChange.originalEndLineNumber\n                        && zone.diff.modifiedStartLineNumber === lineChange.modifiedStartLineNumber\n                        && zone.diff.modifiedEndLineNumber === lineChange.modifiedEndLineNumber) {\n                        zoneHeightInLines = zone.heightInLines;\n                    }\n                }\n                const viewRange = getViewRange(originalModel, originalViewModel, lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, zoneHeightInLines, overviewZoneColor));\n            }\n        }\n        return result;\n    }\n    _getModifiedEditorDecorations(zones, lineChanges, ignoreTrimWhitespace, renderIndicators) {\n        const modifiedEditor = this._dataSource.getModifiedEditor();\n        const overviewZoneColor = String(this._insertColor);\n        const result = {\n            decorations: [],\n            overviewZones: []\n        };\n        const modifiedModel = modifiedEditor.getModel();\n        const modifiedViewModel = modifiedEditor._getViewModel();\n        for (const lineChange of lineChanges) {\n            // Add decorations & overview zones\n            if (isChangeOrInsert(lineChange)) {\n                result.decorations.push({\n                    range: new Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n                    options: (renderIndicators ? DECORATIONS.lineInsertWithSign : DECORATIONS.lineInsert)\n                });\n                const viewRange = getViewRange(modifiedModel, modifiedViewModel, lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);\n                result.overviewZones.push(new OverviewRulerZone(viewRange.startLineNumber, viewRange.endLineNumber, /*use endLineNumber*/ 0, overviewZoneColor));\n                if (lineChange.charChanges) {\n                    for (const charChange of lineChange.charChanges) {\n                        if (isChangeOrInsert(charChange)) {\n                            if (ignoreTrimWhitespace) {\n                                for (let lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {\n                                    let startColumn;\n                                    let endColumn;\n                                    if (lineNumber === charChange.modifiedStartLineNumber) {\n                                        startColumn = charChange.modifiedStartColumn;\n                                    }\n                                    else {\n                                        startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);\n                                    }\n                                    if (lineNumber === charChange.modifiedEndLineNumber) {\n                                        endColumn = charChange.modifiedEndColumn;\n                                    }\n                                    else {\n                                        endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);\n                                    }\n                                    result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, DECORATIONS.charInsert));\n                                }\n                            }\n                            else {\n                                result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, DECORATIONS.charInsert));\n                            }\n                        }\n                    }\n                }\n                else {\n                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */, DECORATIONS.charInsertWholeLine));\n                }\n            }\n        }\n        return result;\n    }\n    layout() {\n        // An editor should not be smaller than 5px\n        return Math.max(5, this._decorationsLeft);\n    }\n}\nclass InlineViewZonesComputer extends ViewZonesComputer {\n    constructor(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {\n        super(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);\n        this._originalModel = originalEditor.getModel();\n        this._renderIndicators = renderIndicators;\n        this._pendingLineChange = [];\n        this._pendingViewZones = [];\n        this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();\n    }\n    getViewZones() {\n        const result = super.getViewZones();\n        this._finalize(result);\n        return result;\n    }\n    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {\n        const result = document.createElement('div');\n        result.className = 'inline-added-margin-view-zone';\n        return result;\n    }\n    _produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        const marginDomNode = document.createElement('div');\n        marginDomNode.className = 'inline-added-margin-view-zone';\n        return {\n            afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),\n            heightInLines: lineChangeModifiedLength,\n            domNode: document.createElement('div'),\n            marginDomNode: marginDomNode\n        };\n    }\n    _produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {\n        const domNode = document.createElement('div');\n        domNode.className = `view-lines line-delete ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`;\n        const marginDomNode = document.createElement('div');\n        marginDomNode.className = 'inline-deleted-margin-view-zone';\n        const viewZone = {\n            shouldNotShrink: true,\n            afterLineNumber: (lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1),\n            heightInLines: lineChangeOriginalLength,\n            minWidthInPx: 0,\n            domNode: domNode,\n            marginDomNode: marginDomNode,\n            diff: {\n                originalStartLineNumber: lineChange.originalStartLineNumber,\n                originalEndLineNumber: lineChange.originalEndLineNumber,\n                modifiedStartLineNumber: lineChange.modifiedStartLineNumber,\n                modifiedEndLineNumber: lineChange.modifiedEndLineNumber,\n                originalModel: this._originalModel,\n                viewLineCounts: null,\n            }\n        };\n        for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {\n            this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(lineNumber), null, null);\n        }\n        this._pendingLineChange.push(lineChange);\n        this._pendingViewZones.push(viewZone);\n        return viewZone;\n    }\n    _finalize(result) {\n        const modifiedEditorOptions = this._modifiedEditor.getOptions();\n        const tabSize = this._modifiedEditor.getModel().getOptions().tabSize;\n        const fontInfo = modifiedEditorOptions.get(44 /* fontInfo */);\n        const disableMonospaceOptimizations = modifiedEditorOptions.get(29 /* disableMonospaceOptimizations */);\n        const typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastColumn = modifiedEditorOptions.get(93 /* scrollBeyondLastColumn */);\n        const mightContainNonBasicASCII = this._originalModel.mightContainNonBasicASCII();\n        const mightContainRTL = this._originalModel.mightContainRTL();\n        const lineHeight = modifiedEditorOptions.get(59 /* lineHeight */);\n        const layoutInfo = modifiedEditorOptions.get(131 /* layoutInfo */);\n        const lineDecorationsWidth = layoutInfo.decorationsWidth;\n        const stopRenderingLineAfter = modifiedEditorOptions.get(105 /* stopRenderingLineAfter */);\n        const renderWhitespace = modifiedEditorOptions.get(88 /* renderWhitespace */);\n        const renderControlCharacters = modifiedEditorOptions.get(83 /* renderControlCharacters */);\n        const fontLigatures = modifiedEditorOptions.get(45 /* fontLigatures */);\n        const lineBreaks = this._lineBreaksComputer.finalize();\n        let lineBreakIndex = 0;\n        for (let i = 0; i < this._pendingLineChange.length; i++) {\n            const lineChange = this._pendingLineChange[i];\n            const viewZone = this._pendingViewZones[i];\n            const domNode = viewZone.domNode;\n            applyFontInfo(domNode, fontInfo);\n            const marginDomNode = viewZone.marginDomNode;\n            applyFontInfo(marginDomNode, fontInfo);\n            const decorations = [];\n            if (lineChange.charChanges) {\n                for (const charChange of lineChange.charChanges) {\n                    if (isChangeOrDelete(charChange)) {\n                        decorations.push(new InlineDecoration(new Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), 'char-delete', 0 /* Regular */));\n                    }\n                }\n            }\n            const hasCharChanges = (decorations.length > 0);\n            const sb = createStringBuilder(10000);\n            let maxCharsPerLine = 0;\n            let renderedLineCount = 0;\n            let viewLineCounts = null;\n            for (let lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {\n                const lineIndex = lineNumber - lineChange.originalStartLineNumber;\n                const lineTokens = this._originalModel.getLineTokens(lineNumber);\n                const lineContent = lineTokens.getLineContent();\n                const lineBreakData = lineBreaks[lineBreakIndex++];\n                const actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, lineContent.length + 1);\n                if (lineBreakData) {\n                    let lastBreakOffset = 0;\n                    for (const breakOffset of lineBreakData.breakOffsets) {\n                        const viewLineTokens = lineTokens.sliceAndInflate(lastBreakOffset, breakOffset, 0);\n                        const viewLineContent = lineContent.substring(lastBreakOffset, breakOffset);\n                        maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, viewLineContent, viewLineTokens, LineDecoration.extractWrapped(actualDecorations, lastBreakOffset, breakOffset), hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));\n                        lastBreakOffset = breakOffset;\n                    }\n                    if (!viewLineCounts) {\n                        viewLineCounts = [];\n                    }\n                    // make sure all lines before this one have an entry in `viewLineCounts`\n                    while (viewLineCounts.length < lineIndex) {\n                        viewLineCounts[viewLineCounts.length] = 1;\n                    }\n                    viewLineCounts[lineIndex] = lineBreakData.breakOffsets.length;\n                    viewZone.heightInLines += (lineBreakData.breakOffsets.length - 1);\n                    const marginDomNode2 = document.createElement('div');\n                    marginDomNode2.className = 'gutter-delete';\n                    result.original.push({\n                        afterLineNumber: lineNumber,\n                        afterColumn: 0,\n                        heightInLines: lineBreakData.breakOffsets.length - 1,\n                        domNode: createFakeLinesDiv(),\n                        marginDomNode: marginDomNode2\n                    });\n                }\n                else {\n                    maxCharsPerLine = Math.max(maxCharsPerLine, this._renderOriginalLine(renderedLineCount++, lineContent, lineTokens, actualDecorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode));\n                }\n            }\n            maxCharsPerLine += scrollBeyondLastColumn;\n            const html = sb.build();\n            const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;\n            domNode.innerHTML = trustedhtml;\n            viewZone.minWidthInPx = (maxCharsPerLine * typicalHalfwidthCharacterWidth);\n            if (viewLineCounts) {\n                // make sure all lines have an entry in `viewLineCounts`\n                const cnt = lineChange.originalEndLineNumber - lineChange.originalStartLineNumber;\n                while (viewLineCounts.length <= cnt) {\n                    viewLineCounts[viewLineCounts.length] = 1;\n                }\n            }\n            viewZone.diff.viewLineCounts = viewLineCounts;\n        }\n        result.original.sort((a, b) => {\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n    }\n    _renderOriginalLine(renderedLineCount, lineContent, lineTokens, decorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, fontInfo, disableMonospaceOptimizations, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, tabSize, sb, marginDomNode) {\n        sb.appendASCIIString('<div class=\"view-line');\n        if (!hasCharChanges) {\n            // No char changes\n            sb.appendASCIIString(' char-delete');\n        }\n        sb.appendASCIIString('\" style=\"top:');\n        sb.appendASCIIString(String(renderedLineCount * lineHeight));\n        sb.appendASCIIString('px;width:1000000px;\">');\n        const isBasicASCII = ViewLineRenderingData.isBasicASCII(lineContent, mightContainNonBasicASCII);\n        const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII, mightContainRTL);\n        const output = renderViewLine(new RenderLineInput((fontInfo.isMonospace && !disableMonospaceOptimizations), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII, containsRTL, 0, lineTokens, decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null // Send no selections, original line cannot be selected\n        ), sb);\n        sb.appendASCIIString('</div>');\n        if (this._renderIndicators) {\n            const marginElement = document.createElement('div');\n            marginElement.className = `delete-sign ${ThemeIcon.asClassName(diffRemoveIcon)}`;\n            marginElement.setAttribute('style', `position:absolute;top:${renderedLineCount * lineHeight}px;width:${lineDecorationsWidth}px;height:${lineHeight}px;right:0;`);\n            marginDomNode.appendChild(marginElement);\n        }\n        return output.characterMapping.getAbsoluteOffset(output.characterMapping.length);\n    }\n}\nfunction validateDiffWordWrap(value, defaultValue) {\n    return validateStringSetOption(value, defaultValue, ['off', 'on', 'inherit']);\n}\nfunction isChangeOrInsert(lineChange) {\n    return lineChange.modifiedEndLineNumber > 0;\n}\nfunction isChangeOrDelete(lineChange) {\n    return lineChange.originalEndLineNumber > 0;\n}\nfunction createFakeLinesDiv() {\n    const r = document.createElement('div');\n    r.className = 'diagonal-fill';\n    return r;\n}\nfunction getViewRange(model, viewModel, startLineNumber, endLineNumber) {\n    const lineCount = model.getLineCount();\n    startLineNumber = Math.min(lineCount, Math.max(1, startLineNumber));\n    endLineNumber = Math.min(lineCount, Math.max(1, endLineNumber));\n    return viewModel.coordinatesConverter.convertModelRangeToViewRange(new Range(startLineNumber, model.getLineMinColumn(startLineNumber), endLineNumber, model.getLineMaxColumn(endLineNumber)));\n}\nfunction validateDiffEditorOptions(options, defaults) {\n    return {\n        enableSplitViewResizing: validateBooleanOption(options.enableSplitViewResizing, defaults.enableSplitViewResizing),\n        renderSideBySide: validateBooleanOption(options.renderSideBySide, defaults.renderSideBySide),\n        maxComputationTime: clampedInt(options.maxComputationTime, defaults.maxComputationTime, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n        maxFileSize: clampedInt(options.maxFileSize, defaults.maxFileSize, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),\n        ignoreTrimWhitespace: validateBooleanOption(options.ignoreTrimWhitespace, defaults.ignoreTrimWhitespace),\n        renderIndicators: validateBooleanOption(options.renderIndicators, defaults.renderIndicators),\n        originalEditable: validateBooleanOption(options.originalEditable, defaults.originalEditable),\n        diffCodeLens: validateBooleanOption(options.diffCodeLens, defaults.diffCodeLens),\n        renderOverviewRuler: validateBooleanOption(options.renderOverviewRuler, defaults.renderOverviewRuler),\n        diffWordWrap: validateDiffWordWrap(options.diffWordWrap, defaults.diffWordWrap),\n    };\n}\nfunction changedDiffEditorOptions(a, b) {\n    return {\n        enableSplitViewResizing: (a.enableSplitViewResizing !== b.enableSplitViewResizing),\n        renderSideBySide: (a.renderSideBySide !== b.renderSideBySide),\n        maxComputationTime: (a.maxComputationTime !== b.maxComputationTime),\n        maxFileSize: (a.maxFileSize !== b.maxFileSize),\n        ignoreTrimWhitespace: (a.ignoreTrimWhitespace !== b.ignoreTrimWhitespace),\n        renderIndicators: (a.renderIndicators !== b.renderIndicators),\n        originalEditable: (a.originalEditable !== b.originalEditable),\n        diffCodeLens: (a.diffCodeLens !== b.diffCodeLens),\n        renderOverviewRuler: (a.renderOverviewRuler !== b.renderOverviewRuler),\n        diffWordWrap: (a.diffWordWrap !== b.diffWordWrap),\n    };\n}\nregisterThemingParticipant((theme, collector) => {\n    const added = theme.getColor(diffInserted);\n    if (added) {\n        collector.addRule(`.monaco-editor .char-insert, .monaco-diff-editor .char-insert { background-color: ${added}; }`);\n    }\n    const lineAdded = theme.getColor(diffInsertedLine) || added;\n    if (lineAdded) {\n        collector.addRule(`.monaco-editor .line-insert, .monaco-diff-editor .line-insert { background-color: ${lineAdded}; }`);\n    }\n    const gutterAdded = theme.getColor(diffInsertedLineGutter) || lineAdded;\n    if (gutterAdded) {\n        collector.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${gutterAdded}; }`);\n        collector.addRule(`.monaco-editor .gutter-insert, .monaco-diff-editor .gutter-insert { background-color: ${gutterAdded}; }`);\n    }\n    const removed = theme.getColor(diffRemoved);\n    if (removed) {\n        collector.addRule(`.monaco-editor .char-delete, .monaco-diff-editor .char-delete { background-color: ${removed}; }`);\n    }\n    const lineRemoved = theme.getColor(diffRemovedLine) || removed;\n    if (lineRemoved) {\n        collector.addRule(`.monaco-editor .line-delete, .monaco-diff-editor .line-delete { background-color: ${lineRemoved}; }`);\n    }\n    const gutterRemoved = theme.getColor(diffRemovedLineGutter) || lineRemoved;\n    if (gutterRemoved) {\n        collector.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${gutterRemoved}; }`);\n        collector.addRule(`.monaco-editor .gutter-delete, .monaco-diff-editor .gutter-delete { background-color: ${gutterRemoved}; }`);\n    }\n    const addedOutline = theme.getColor(diffInsertedOutline);\n    if (addedOutline) {\n        collector.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${addedOutline}; }`);\n    }\n    const removedOutline = theme.getColor(diffRemovedOutline);\n    if (removedOutline) {\n        collector.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${removedOutline}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${shadow}; }`);\n    }\n    const border = theme.getColor(diffBorder);\n    if (border) {\n        collector.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${border}; }`);\n    }\n    const scrollbarSliderBackgroundColor = theme.getColor(scrollbarSliderBackground);\n    if (scrollbarSliderBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport {\n\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderHoverBackgroundColor = theme.getColor(scrollbarSliderHoverBackground);\n    if (scrollbarSliderHoverBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport:hover {\n\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const scrollbarSliderActiveBackgroundColor = theme.getColor(scrollbarSliderActiveBackground);\n    if (scrollbarSliderActiveBackgroundColor) {\n        collector.addRule(`\n\t\t\t.monaco-diff-editor .diffViewport:active {\n\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t}\n\t\t`);\n    }\n    const diffDiagonalFillColor = theme.getColor(diffDiagonalFill);\n    collector.addRule(`\n\t.monaco-editor .diagonal-fill {\n\t\tbackground-image: linear-gradient(\n\t\t\t-45deg,\n\t\t\t${diffDiagonalFillColor} 12.5%,\n\t\t\t#0000 12.5%, #0000 50%,\n\t\t\t${diffDiagonalFillColor} 50%, ${diffDiagonalFillColor} 62.5%,\n\t\t\t#0000 62.5%, #0000 100%\n\t\t);\n\t\tbackground-size: 8px 8px;\n\t}\n\t`);\n});\n",
      "start": 1711096854383,
      "end": 1711096854440,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1711096854440,
      "end": 1711096854440,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1711096854440,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1711096854441,
      "end": 1711096854441,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1711096854441,
      "end": 1711096854451,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1711096854451,
      "end": 1711096854451,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1711096854451,
      "end": 1711096854451,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1711096854451,
      "end": 1711096854451,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1711096854451,
      "end": 1711096854451,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1711096854451,
      "end": 1711096854452,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1711096854452,
      "end": 1711096854452,
      "order": "normal"
    }
  ]
}
